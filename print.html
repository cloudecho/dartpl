<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>从0开始学Dart</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-G1TV36NZV5"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-G1TV36NZV5');
        </script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">从0开始学Dart</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="前言"><a class="header" href="#前言">前言</a></h1>
<p>如果你正在寻找一个跨平台的原生应用开发方案，你可能已经了解过Flutter，ReactNative等。
Dart是Flutter应用的开发语言，它专为客户端优化，支持自动内存管理和面向对象编程。
这里的跨平台指的是一套代码，可发布成 iOS、Android、macOS、Linux、Windows及Web应用。
原生应用是指代码最终被编译为平台相关的机器码；对web而言，对应的是javascript+WebAssembly。</p>
<pre class="mermaid">mindmap
  root((Dart))
    自动内存管理
    面向对象编程
    客户端优化
</pre>
<p>如何你初学编程，一下子听到这么多概念，也许还没开始写一行代码就已经开始糊涂了，没有关系。
要知道，计算机编程就像英语一样，要掌握它，除了需要兴趣之外，还需要良好的思维模式以及坚持不懈的练习。
希望你在学习本课程时，打开代码编辑器，跟着一起练习，为以后编程打下坚实的基础。在你掌握了一门编程语言之后，再去学其他编程语言就容易多了。</p>
<h2 id="读者范围"><a class="header" href="#读者范围">读者范围</a></h2>
<p>本课程将详细介绍Dart 3编程语言 ，从基本语法与控制结构到异步编程，从面向对象编程到编码准则；课程内容由浅入深，既有理论讲解又有代码示例 。相信无论你是编程新手还是具有一定经验的程序员，你都可以从本课程中获益。</p>
<h2 id="课程内容简介"><a class="header" href="#课程内容简介">课程内容简介</a></h2>
<p>第1章，从0开始搭建开发环境，学习 dart变量与数据类型及操作符。</p>
<p>第2章，控制流、函数及异常处理。</p>
<p>第3章，Dart 强大的模式匹配功能。</p>
<p>第4-5章，Dart 的 面向对象编程(OOP)，第4章学习用于封装信息的class（类）的构造，第5章学习类的继承及扩展。</p>
<p>第6章，集合与泛型。</p>
<p>第7章，异步编程。</p>
<p>第8章，单元测试。</p>
<p>附录包括dart命令行工具、编码准则、Dart命令行及服务端编程，以及常用package介绍。</p>
<p>本课程中的代码可免费下载，使用的dart版本为3.8+。</p>
<p>最后，希望本课程能对你的dart学习之旅助一臂之力，祝你学习愉快。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-dart-搭建开发环境"><a class="header" href="#hello-dart-搭建开发环境">Hello Dart: 搭建开发环境</a></h1>
<p>搭建开发环境是我们编程的起点，新手有可能卡在这一步。如果你是经验丰富的程序员，可以直接跳过。搭建开发环境需要考虑的两个主要问题是开发机的操作系统与网络环境。</p>
<p>我们的开发电脑的操作系统可能是下列之一:</p>
<ul>
<li>macOS  Sonoma (14), Ventura (13), Monterey (12)</li>
<li>Windows  10,11</li>
<li>ChromeOS</li>
<li>Linux
<ul>
<li>Debian stable</li>
<li>Ubuntu LTS</li>
<li>其他，如Manjaro，CentOS Stream，Linux Mint</li>
</ul>
</li>
</ul>
<p>这里推荐的操作系统是 MacOS 或 Linux ，因为它们具有更丰富的开发工具及各种命令，极大的方便了软件开发。如果你使用的计算机网络位于中国，由于其网络特殊性，可能需要使用相关资源（各软件包/工具/在线服务）的镜像。</p>
<h2 id="dartdev"><a class="header" href="#dartdev">Dart.dev</a></h2>
<p>如果你只是想快速搭建Dart或Flutter开发环境，可以跳过本段。</p>
<ol>
<li>首先我们去Dart官网 https://dart.dev ，点击右上角的 <a href="https://dart.dev/get-dart">Get Dart</a>。</li>
</ol>
<p>注意页面上的提示，如果你已经安装或打算安装Flutter SDK，可以跳过该向导，因为Flutter SDK包含了Dart SDK。 我们学习Dart最主要的目的就是使用Flutter框架，编写跨平台App。因此，我们这里直接安装Flutter SDK。</p>
<ol start="2">
<li>点击 <a href="https://docs.flutter.dev/get-started/install">install the Flutter SDK</a>， 我们来到了Flutter SDK 安装向导页。</li>
</ol>
<p>操作系统及网络环境的不同，会导致搭建Dart开发环境的方式也有所不同。但是这些方式有着类似的步骤。本文选取 <code>中国网络环境下的Linux系统</code> 对这些步骤进行说明。</p>
<h2 id="在中国网络环境下使用-flutter"><a class="header" href="#在中国网络环境下使用-flutter">在中国网络环境下使用 Flutter</a></h2>
<p>有必要解释一下镜像或镜像站点。 Flutter SDK （软件开发工具包）或 Dart SDK 以及 dart package（软件包）（发布于pub.dev网站），是我们开发Flutter或Dart程序必备的，但由于中国网络的特殊性，导致许多中国开发者无法直接（从官方服务器，由谷歌维护）获取这些SDK或package（或者下载速度极慢），所以我们就去官方服务器的镜像站点去下载。这些位于中国的镜像站点会定时与官方服务器同步，略有延迟。</p>
<ol>
<li>在电脑上打开 terminal （终端命令行界面），以上海交通大学*nix用户组镜像为例，配置镜像</li>
</ol>
<pre><code class="language-sh">export PUB_HOSTED_URL=https://mirror.sjtu.edu.cn/dart-pub
export FLUTTER_STORAGE_BASE_URL=https://mirror.sjtu.edu.cn
</code></pre>
<ol start="2">
<li>从镜像站点下载 Flutter 压缩包</li>
</ol>
<p>以 Flutter 3.32.2 为例， 使用如下命令下载</p>
<pre><code class="language-sh">wget -c -O flutter_linux_3.32.2-stable.tar.xz  $FLUTTER_STORAGE_BASE_URL/flutter_infra_release/releases/stable/linux/flutter_linux_3.32.2-stable.tar.xz
</code></pre>
<p>注:  macOS与windows对应的下载地址分别为</p>
<pre><code class="language-sh">$FLUTTER_STORAGE_BASE_URL/flutter_infra_release/releases/stable/macos/flutter_macos_3.32.2-stable.zip

$FLUTTER_STORAGE_BASE_URL/flutter_infra_release/releases/stable/windows/flutter_windows_3.32.2-stable.zip
</code></pre>
<ol start="3">
<li>创建一个文件夹，用于安装Flutter， 例如 ~/dev</li>
</ol>
<pre><code class="language-sh">mkdir ~/dev
cd ~/dev
</code></pre>
<ol start="4">
<li>将 flutter_linux_3.32.2-stable.tar.xz 拷贝到当前目录，然后解压</li>
</ol>
<pre><code class="language-sh">tar -xf flutter_linux_3.32.2-stable.tar.xz
</code></pre>
<ol start="5">
<li>将 Flutter 添加到PATH 环境变量中</li>
</ol>
<pre><code class="language-sh">export PATH="$PWD/flutter/bin:$PATH"
</code></pre>
<ol start="6">
<li>运行 <code>flutter doctor</code> 来验证安装</li>
</ol>
<pre><code class="language-sh">$ flutter doctor

Flutter assets will be downloaded from https://mirror.sjtu.edu.cn. Make sure you trust this
source!
Doctor summary (to see all details, run flutter doctor -v):
[✓] Flutter (Channel stable, 3.32.2, on Manjaro Linux 6.6.63-1-MANJARO, locale en_US.UTF-8)
[✓] Android toolchain - develop for Android devices (Android SDK version 34.0.0)
[✓] Chrome - develop for the web
[✓] Linux toolchain - develop for Linux desktop
[✓] Android Studio (version 2023.2)
[✓] IntelliJ IDEA Community Edition (version 2024.3)
[✓] VS Code (version unknown)
    ✗ Unable to determine VS Code version.
[✓] Connected device (2 available)
[✓] Network resources

• No issues found!

</code></pre>
<p>查看 Flutter 及 Dart 版本</p>
<pre><code class="language-sh">$ flutter --version                                                        ✔ 
Flutter 3.32.2 • channel stable • https://github.com/flutter/flutter.git
Framework • revision 8defaa71a7 (4 days ago) • 2025-06-04 11:02:51 -0700
Engine • revision 1091508939 (9 days ago) • 2025-05-30 12:17:36 -0700
Tools • Dart 3.8.1 • DevTools 2.45.1

$ dart --version                                                           ✔ 
Dart SDK version: 3.8.1 (stable) (Wed May 28 00:47:25 2025 -0700) on "linux_x64"

</code></pre>
<h2 id="配置环境变量"><a class="header" href="#配置环境变量">配置环境变量</a></h2>
<p>在上述过程过程中， export 设置的环境变量，仅对当前terminal有效；要永久设置这些值，
将这三条 export 指令添加到首选 shell 使用的 *rc 或 *profile 文件中，例如</p>
<pre><code class="language-sh">cat &lt;&lt;EOF &gt;&gt; ~/.zshrc
export PUB_HOSTED_URL=https://mirror.sjtu.edu.cn/dart-pub
export FLUTTER_STORAGE_BASE_URL=https://mirror.sjtu.edu.cn
export PATH="\$HOME/dev/flutter/bin:\$PATH"
EOF
</code></pre>
<p>使用 <code>tail</code> 命令查看刚才写入的内容</p>
<pre><code class="language-sh">tail -3 ~/.zshrc
</code></pre>
<h2 id="hello-dart"><a class="header" href="#hello-dart">Hello Dart</a></h2>
<p>下面我们来创建第一个Dart.</p>
<pre><code class="language-sh">$ dart create hellodart         
Creating hellodart using template console...

  .gitignore
  analysis_options.yaml
  CHANGELOG.md
  pubspec.yaml
  README.md
  bin/hellodart.dart
  lib/hellodart.dart
  test/hellodart_test.dart

</code></pre>
<p>执行完<code>dart create</code>命令之后， 我们得到了一个<code>hello world </code> project.</p>
<p>下面我们来运行一下</p>
<pre><code class="language-sh">$ dart run                        ✔ 
Building package executable... 
Built hellodart:hellodart.
Hello world: 42!
</code></pre>
<p>编译为可执行程序</p>
<pre><code class="language-sh">$ dart compile exe bin/hellodart.dart

$ ./bin/hellodart.exe             ✔ 
Hello world: 42!
</code></pre>
<p>dart 是一个强大的命令，关于它的基本使用，本课程将其放在附录中说明。</p>
<h2 id="安装ide-集成开发环境代码编辑器"><a class="header" href="#安装ide-集成开发环境代码编辑器">安装IDE （集成开发环境，代码编辑器）</a></h2>
<p>有几款优秀且跨平台的IDE可供选用：</p>
<ul>
<li>VSCode: <a href="https://code.visualstudio.com/download">https://code.visualstudio.com/download</a></li>
<li>Android Studio: <a href="https://developer.android.com/studio/install">https://developer.android.com/studio/install</a></li>
<li>IntelliJ IDEA: <a href="https://www.jetbrains.com/idea/download/">https://www.jetbrains.com/idea/download/</a></li>
</ul>
<p>下载安装好IDE后，再打开IDE安装Dart扩展。</p>
<p>另外，<a href="https://dartpad.dev/">dartpad.dev</a>是一个在线编辑器，可用于临时测试一些代码。</p>
<p>如果你看到了这里，并且也跟着一起练习，那么恭喜你，你已经开启了Dart编程之旅。</p>
<h2 id="附-社区镜像站点"><a class="header" href="#附-社区镜像站点">附: 社区镜像站点</a></h2>
<pre><code class="language-sh"># 上海交通大学 *nix 用户组
export PUB_HOSTED_URL=https://mirror.sjtu.edu.cn/dart-pub;
export FLUTTER_STORAGE_BASE_URL=https://mirror.sjtu.edu.cn

# 清华大学 TUNA 协会
export PUB_HOSTED_URL=https://mirrors.tuna.tsinghua.edu.cn/dart-pub
export FLUTTER_STORAGE_BASE_URL=https://mirrors.tuna.tsinghua.edu.cn/flutter

# 中国 Flutter 社区 (CFUG)
export PUB_HOSTED_URL=https://pub.flutter-io.cn
export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn

</code></pre>
<h2 id="参考资料"><a class="header" href="#参考资料">参考资料</a></h2>
<ul>
<li><a href="https://docs.flutter.cn/community/china/">https://docs.flutter.cn/community/china/</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="变量与null-safety"><a class="header" href="#变量与null-safety">变量与Null safety</a></h1>
<h2 id="什么是变量"><a class="header" href="#什么是变量">什么是变量</a></h2>
<p>计算机编程语言里的变量（Variable）与数学公式里的变量类似。请看下面这段Dart代码:</p>
<pre><code class="language-dart">// ch0102-1
void main() {
  var x = 3;  // 1
  var (y, z) = (4, 5); // 2
  print('x = $x, y = $y, z = $z'); // 3 Output: x = 3, y = 4, z = 5
  print('x + y + z = ${x + y + z}'); // 4 Output: x + y + z = 12
}
</code></pre>
<p>这段简短的代码只有一个函数，那就是<code>main</code>，整个程序的入口。代码中的 <code>//</code> 是注释，是为了帮助人们阅读代码，Dart编译器会忽略它。</p>
<ol>
<li>使用<code>var</code>关键字，声明变量x，并给<code>x</code>赋值为 3，Dart编译器自动推断其类型为<code> int</code> （integer, 整数）;</li>
<li>同时声明两个变量<code>x</code>和<code>y</code>，分别赋值为4和5，这里使用了record的模式匹配（第3章内容，这里看不懂也没关系）;</li>
<li>分别将<code>x</code>，<code>y</code>，<code>z</code>的值打印（显示）到控制台（标准输出设备 stdout）；</li>
<li>计算 <code>x + y + z</code> 并打印。</li>
</ol>
<p>第1句也可以写成 <code>int x = 3;</code> 也等同于</p>
<pre><code class="language-dart">int x;
x = 3;
</code></pre>
<p>第2句也可以写成</p>
<pre><code class="language-dart">  var y= 4, z = 5;
</code></pre>
<p>第3、4两句中的 <code>$x</code>, <code>$y</code>, <code>$z</code> 以及 <code>${x + y + z}</code> 为 字符串插值，非常直观和方便。</p>
<p><code>var x </code>声明了一个变量，它的标识符为<code>x</code>; 标识符，通俗地说就是给变量、函数、类、方法等起个名字，方便使用，就像我们给宠物取个名，方便呼唤。Dart语言的标识符可以是下列字符的组合：</p>
<ul>
<li>字母</li>
<li>数字</li>
<li><code>_</code> 和 <code>$</code></li>
</ul>
<p>但不能以数字开头。这些都是合法的标识符:  <code>practiceMakesPerfect</code>, <code>_imPrivate</code>, <code>_$GeneratedCode</code>, <code>$happy365</code>。Dart里以下划线（<code>_</code> ）开头的变量是私有变量。</p>
<p><code>var</code>修饰的变量 ，可以后续更改，比如</p>
<pre><code class="language-dart">// ch0102-3
void main() {
  var x = 3;
  x = 30;
  print('x = $x'); // Output: x = 30
}
</code></pre>
<p>变量除了可以表示数字，还可以表示文本（字符串）等.  例如</p>
<pre><code class="language-dart">// ch0102-4
void main(){
  var name = 'Dart';
  print('Hello, $name!'); // Output: Hello, Dart!
}
</code></pre>
<p>这里的数字、字符串等，就是所谓的数据类型（本章第4节内容，这里不再展开）。</p>
<h2 id="优先使用-var-声明变量"><a class="header" href="#优先使用-var-声明变量">优先使用 <code>var </code>声明变量</a></h2>
<p>对于  <code>var x = 3;</code> 也可以写成 <code>int x = 3</code>，你可能有个疑问，哪种情况下用哪种方式呢？官方的建议是，多数情况下，我们应该使用 var (而非实际类型) 声明变量，这样做除了可以使代码更短之外，还能提高代码的可读性。</p>
<p>如果我们仅仅声明变量（不赋值），应该写出实际的类型，因为这时候Dart无法推断出变量的数据类型，如</p>
<pre><code class="language-dart">int x;
</code></pre>
<p>如果我们这样写</p>
<pre><code class="language-dart">var x;
</code></pre>
<p>Dart编译器就认为 x 的类型为 <code>dynamic</code> ，这种类型可以表示任何数据，通常情况下我们应该避免这样做，因为Dart的静态类型检查对<code>dynamic</code>无效（可能暗藏bug）。</p>
<h2 id="使用--late-延迟初始化"><a class="header" href="#使用--late-延迟初始化">使用  <code>late</code> 延迟初始化</a></h2>
<p>有时候我们希望延迟变量的初始化（特别在Flutter的StatefulWidget中），这时就用到 <code>late</code> 关键字， 例如</p>
<pre><code class="language-dart">// ch0102-5
void main() {
  late String action = 'go camping';
  var isReady = true; // it may take some time to prepare
  if (isReady) {
    print("Let's $action!"); // Output: Let's go camping!
  }
}
</code></pre>
<p>这里先了解下，第4章会有更多关于 <code>late</code>  的讨论。</p>
<h2 id="null-safety"><a class="header" href="#null-safety">Null safety</a></h2>
<h3 id="nnbd"><a class="header" href="#nnbd">NNBD</a></h3>
<p>从Dart 2.10 开始，变量默认非 <code>null</code>（non-nullable by defaullt, NNBD)；<code>null</code> 表示空值。 比如下面这段代码无法编译</p>
<pre><code class="language-dart">// ch0102-6
void main() {
  int x;
  print('x = $x'); 

  // Error: Non-nullable variable 'x' must be assigned before it can be used.
  // print('x = $x'); 
  //             ^
}
</code></pre>
<p>当我们尝试编译上面这段代码时，出现编译错误，告诉我们在使用变量<code>x</code>之前必须初始化它。</p>
<p>如果要使用<code>null</code>， 可以像下面这样:</p>
<pre><code class="language-dart">// ch0102-7
void main() {
  int? x;
  print('x = $x'); // Output: x = null
}
</code></pre>
<p>这里的 <code> int? x</code> 表示变量<code>x</code> 的初始值为<code>null</code>,   <code>x</code> 是一个nullable变量。</p>
<p>注：
熟悉Java的朋友想必对<code>NullPointerException</code> (NPE) 并不陌生，这个Exception是一个运行时异常；为了提高代码的健壮性，经常要对方法的入参进行非空检查，否则就很容易遭遇NPE（这个问题有时难以排查，尤其在大型软件项目里）。例如下面这段Java代码</p>
<pre><code class="language-java">void doSomething(String str) {
  if (str == null){
    throw new IllegalArgumentException("doSomething: str cannot be null");
  }
  // Do something
}
</code></pre>
<p>我想这便是Dart  NNBD的原因。</p>
<h3 id="访问nullable变量"><a class="header" href="#访问nullable变量">访问nullable变量</a></h3>
<p>有几个nullable变量相关的访问/赋值，有必要介绍一下，你以后再看到下面这些符号就不会感到陌生了。</p>
<h3 id="----"><a class="header" href="#----"><code>??</code> 、 <code>??=</code>、  <code>!</code></a></h3>
<pre><code class="language-dart">// ch0102-8
void main() {
  int? x;
  var y = x ?? 10; // 1
  var z = y ?? 20; // 1a
  print('y = $y, z = $z'); // Output: y = 10, z = 10

  int? y2;
  y ??= 100; // 2
  y2 ??= 100; // 2a
  print('y = $y, y2 = $y2'); // Output: y = 10, y2 = 100

  var a = y!; // 3
  print('a = $a'); // Output: a = 10

  var b = x!; // 3a
  print('b = $b');
  // Unhandled exception:
  // Null check operator used on a null value
}
</code></pre>
<ol>
<li>如果 <code>x</code>为<code>null</code>，<code>y</code>赋值为10， 否则将<code>x</code>的值赋给<code>y</code>；</li>
<li>如果 <code>y</code>为<code>null</code>，<code>y</code>赋值为100，否则啥也不做；</li>
<li>断言<code>y</code>一定非空(<code>null</code>)，并将<code>y</code>的值赋给<code>a</code>；如果<code>y</code>为<code>null</code>，在程序运行时会出现一个Null check异常（见3a）。</li>
</ol>
<p>请对比 1和1a， 2和2a，以及3和3a的结果。</p>
<h3 id="-"><a class="header" href="#-"><code>?.</code> 、<code>?[]</code></a></h3>
<pre><code class="language-dart">// ch0102-9
void main() {
  var abc = 'ABCD';
  String? def;

  var first = abc?[0]; // 1
  var second = def?[0]; // 1a
  print('first = $first, second = $second'); // Output: first = A, second = null

  var len1 = abc?.length; // 2
  var len2 = def?.length; // 2a
  print('len1 = $len1, len2 = $len2'); // Output: len1 = 4, len2 = null

  var len3 = def?.length ?? 0; // 3
  print('len3 = $len3'); // Output: len3 = 0
}
</code></pre>
<ol>
<li>如果<code>abc</code>为<code>null</code>，<code>first</code>为<code>null</code>， 否则将<code>abc[0]</code>的值赋给<code>first</code>；</li>
<li>如果<code>abc</code>为<code>null</code>，<code>len1</code>为<code>null</code>， 否则将<code>abc.length</code>的值赋给<code>len1</code>；</li>
<li>这是一个综合的例子，同时使用了 <code>?.</code>与 <code>??</code> 符号。</li>
</ol>
<p>注：本例中的 <code>abc[0]</code> 返回第0个（下标从0开始）unicode字符，<code>abc.length</code>返回<code>abc</code>的长度。</p>
<h3 id=""><a class="header" href="#"><code>...?</code></a></h3>
<pre><code class="language-dart">// ch0102-a
void main() {
  var arr = [1, 2, 3];
  var arr2 = [...arr, 4, 5]; // 1
  print('arr2 = $arr2'); // Output: arr2 = [1, 2, 3, 4, 5]

  var arr3 = [...?arr, 6, 7]; // 1a
  print('arr3 = $arr3'); // Output: arr3 = [1, 2, 3, 6, 7]

  List&lt;int&gt;? arr4;
  var arr5 = [...?arr4, 8, 9]; // 2
  print('arr5 = $arr5'); // Output: arr5 = [8, 9]

  List&lt;int&gt;? arr6 = []; // 3
  var arr7 = [...arr6, -1, -2]; // 3a
  print('arr7 = $arr7'); // Output:  arr7 = [-1, -2]
}
</code></pre>
<ol>
<li><code>arr</code>是一个列表（数组）， <code>...arr</code>将展开<code>arr</code>， 此行代码将<code>arr</code>以及 4, 5 一起组成一个新的列表，并将其赋值给<code>arr2</code>;</li>
<li>本行代码 与 1 类似，  区别在于，这里必须使用  <code>...?arr4</code> 执行展开操作，否则无法编译通过;</li>
<li><code>arr6</code> 跟<code>arr4</code>一样，是一个nullable变量，但其初始值为一个空的列表（不是<code>null</code>），就可以用<code>...</code>对其进行展开，可见Dart编译器非常智能。</li>
</ol>
<h2 id="参考资料-1"><a class="header" href="#参考资料-1">参考资料</a></h2>
<ul>
<li><a href="https://dart.dev/language/variables">https://dart.dev/language/variables</a></li>
<li><a href="https://dart.dev/effective-dart/design#types">https://dart.dev/effective-dart/design#types</a></li>
<li><a href="https://dart.dev/null-safety">https://dart.dev/null-safety</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="final-const-及wildcard"><a class="header" href="#final-const-及wildcard"><code>final</code>、 <code>const</code> 及wildcard</a></h1>
<h2 id="final"><a class="header" href="#final"><code>final</code></a></h2>
<p>声明为final的变量，只能被赋值一次。 如果尝试修改已经赋值过的final变量，会引起编译错误。</p>
<pre><code class="language-dart">// ch0103_1.dart
void main() {
  final myPet = 'Doggy'; // 1
  myPet = 'Kitty'; // 2
  // Error: Can't assign to the final variable 'myPet'.
  // myPet = 'Kitty'; // 2
  // ^^^^^
}
</code></pre>
<ol>
<li>声明一个final变量<code>myPet</code>, 并为其赋值;</li>
<li>尝试修改<code>myPet</code>的值，引起编译错误， 告诉我们不能给final 变量 <code>myPet</code> 赋值。</li>
</ol>
<h2 id="late-final"><a class="header" href="#late-final"><code>late final</code></a></h2>
<p><code>late final</code> 这两个关键字经常一起出现，这里构建了一个简单的例子：</p>
<pre><code class="language-dart">// ch0103_2.dart
void main() {
  final width = 3.0; // 1
  final height = 4.0; // 1a
  late final double perimeter; // 2
  // ... (Do somehting else)
  perimeter = 2 * (width + height); // 3
  print('width: $width, height: $height, perimeter: $perimeter'); // 4
  // Output: width: 3.0, height: 4.0, perimeter: 14.0
}
</code></pre>
<ol>
<li>声明final变量 <code>width</code>与 <code>height</code> ，并分别赋值为3.0与4.0，Dart自动推断其数据类型为<code>double</code> （浮点数）;</li>
<li>使用 <code>late final</code> 声明一个变量<code>perimeter</code>，在这里它表示一个矩形的周长，同时显示指定这个变量的数据类型为<code>double</code>，所以这里有3个关键字<code>late final double</code>，它们一起修饰变量<code>perimeter</code>;</li>
<li>计算变量 <code>perimeter</code>的值，公式为（长+宽）×2;</li>
<li>使用字符串插值，打印相关变量。</li>
</ol>
<p>这个例子似乎看不出 <code>late final</code> 有什么特别之处，这里只是让你熟悉一下，在面向对象编程（OOP）的章节还会继续讨论它。</p>
<h2 id="final-的兄弟-const"><a class="header" href="#final-的兄弟-const"><code>final</code> 的兄弟 <code>const</code></a></h2>
<p><code>const</code>关键字用于：</p>
<ul>
<li>声明一个常量，常量具有编译时（compile-time)不可变性，这里的编译时是与运行时（runtime）相对应的；</li>
<li>创建常量值（constant values）;</li>
<li>定义const构造器，该构造器用于创建常量值。</li>
</ul>
<p>后面两点与OOP有关，这里提前了解下。</p>
<h3 id="声明一个常量"><a class="header" href="#声明一个常量">声明一个常量</a></h3>
<p>试图修改常量会引起编译错误，例如</p>
<pre><code class="language-dart">// ch0103_3.dart
void main(){
  const score = 50; // 1
  score = 80; // 2
  // Error: Can't assign to the const variable 'score'.
  // score = 80; // 2
  // ^^^^^
}
</code></pre>
<h3 id="创建常量值"><a class="header" href="#创建常量值">创建常量值</a></h3>
<p>任何变量都可以有常量值。</p>
<pre><code class="language-dart">// ch0103_4.dart
void main() {
  final luckyNumbers = [5, 6]; // 1
  luckyNumbers.add(8); // 2
  print('luckyNumbers: $luckyNumbers');
  // Output: luckyNumbers: [5, 6, 8]

  const myFriends = ['Alice', 'Bob']; // 3
  myFriends.add('Charlie'); // 4
  // Unhandled exception:
  // Unsupported operation: Cannot add to an unmodifiable list;
}
</code></pre>
<ol>
<li>声明一个<code>final</code> 列表  <code>luckyNumbers</code>并对其初始化，包含5、6两个数字；</li>
<li>向<code>luckyNumbers</code>添加数字8，然后打印出来，luckyNumbers 现在包含了5、6、8三个数字; 这说明了虽然<code>final</code>修饰的luckyNumbers本身（引用）不可更改，但它引用的列表是可以改变的;</li>
<li>声明一个<code>const</code>列表<code>myFriends</code>，初始值包含"Alice和"Bob"两个字符串;</li>
<li>向<code>myFriends</code>添加一个新元素"Charlie"，这引起了一个运行时异常，告诉我们不能向不可变列表添加新的元素，可见<code>const</code>比<code>final</code>具有更强的不可变性。</li>
</ol>
<h3 id="定义const构造器"><a class="header" href="#定义const构造器">定义const构造器</a></h3>
<p>构造器是OOP里的概念，const构造用于创建常量值。请看下面这个示例：</p>
<pre><code class="language-dart">// ch0103_5.dart
class Pet { // 1
  final String name; // 1a
  const Pet(this.name); // 2
}

void main() {
  var myPet = Pet('Doggy'); // 3
  myPet = Pet('Little Doggy'); // 3a
  const yourPet = Pet('Kitty'); // 4

  print('myPet: ${myPet.name}, yourPet: ${yourPet.name}');
  // Output: myPet: Little Doggy, yourPet: Kitty
}
</code></pre>
<ol>
<li><code>class</code>关键字用于声明一个名叫<code>Pet</code>的类 ，类封装了数据和行为（方法）（第4-5章专门讨论OOP）; class <code>Pet</code> 有一个final成员变量叫做 <code>name</code> ;</li>
<li>这是<code>Pet</code>的const构造器;</li>
<li>通过调用<code>Pet</code>的构造器，得到一个<code>Pet</code>的实例（对象）<code>myPet</code>，随后又将<code>myPet</code>指向另一个Pet对象（3a）;</li>
<li>通过调用<code>Pet</code>的const构造器，创建Pet的常量对象 <code>yourPet</code>，这行代码等于</li>
</ol>
<pre><code class="language-dart">  const yourPet = const Pet('Kitty'); // 4
</code></pre>
<p>在常量上下文中，<code>Pet('Kitty')</code>之前省略了<code>const</code>关键字。</p>
<h3 id="常量对象"><a class="header" href="#常量对象">常量对象</a></h3>
<p><code> const Pet('Kitty')</code> 与 <code> Pet('Kitty')</code>是不一样的，前者创建（实例化）了一个常量对象，而后者创建的是非常量对象（除非是在常量上下文中）。</p>
<pre><code class="language-dart">// ch0103_6.dart
void main() {
  const pet1 = Pet('Rabbit'); // 1
  var pet2 = const Pet('Rabbit'); // 2
  final pet3 = Pet('Rabbit'); // 3

  print('${pet1 == pet2}'); // Output: true
  print('${pet1 == pet3}'); // Ouptput: false
}

class Pet {
  final String name;
  const Pet(this.name); 
}
</code></pre>
<p>这里的 <code>==</code> 操作符，用于测试左右两边的操作数是否相等。</p>
<h2 id="wildcard_"><a class="header" href="#wildcard_">Wildcard（<code>_</code>）</a></h2>
<p>自 Dart 3.7  开始，以 <code>_</code>  命名 的变量或参数，是一个通配符（wildcard ），它的值会被丢弃。同一个命名空间里多次声明 <code>_</code> 不会冲突。例如</p>
<pre><code class="language-dart">//ch0103_7.dart
void main() {
  var _ = 10; // 1
  var _ = 'Hello'; // 2
  print('Hello, Dart! $_'); // 3
  // Error: Undefined name '_'.
  // print('Hello, Dart! $_');
}
</code></pre>
<p>上面这段代码比较简单，不过多解释。</p>
<p>通配符出现的地方：</p>
<ul>
<li>变量声明， 如 <code>var _ = 1;</code></li>
<li>for 循环变量 如 <code>for (var _ in list) {}</code></li>
<li>catch 语句参数, 如</li>
</ul>
<pre><code class="language-dart">try {
  throw 'something bad';
} catch (_) {
  print('oops');
}
</code></pre>
<ul>
<li>函数参数，如 <code>list.where((_) =&gt; true);</code></li>
<li>泛型类型及函数类型参数， 如</li>
</ul>
<pre><code class="language-dart">class T&lt;_&gt; {}
void genericFunction&lt;_&gt;() {}
</code></pre>
<p>for循环、函数、catch语句、泛型等概念将在后续章节陆续介绍，这里关于通配符有个印象就行。</p>
<p>更多的示例，可查阅<a href="https://dart.dev/language/variables#wildcard-variables">官方文档</a>。</p>
<h2 id="参考资料-2"><a class="header" href="#参考资料-2">参考资料</a></h2>
<ul>
<li><a href="https://dart.dev/language/variable">https://dart.dev/language/variable</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h1>
<p>通常计算机编程语言里的数据类型可以分为基础数据类型与复合数据类型两大类。Dart的基础数据类型包括：</p>
<ul>
<li><a href="ch01/dartpl0104.html#%E6%95%B0%E5%AD%97">数字（int 整数，double 浮点数）</a></li>
<li><a href="ch01/dartpl0104.html#%E5%AD%97%E7%AC%A6%E4%B8%B2string">字符串 （String）</a></li>
<li><a href="ch01/dartpl0104.html#%E5%B8%83%E5%B0%94bool">布尔 （bool）</a></li>
<li><a href="ch01/dartpl0104.html#%E7%AC%A6%E6%96%87rune">符文（Rune， 通常使用 <code>characters</code> API）</a></li>
</ul>
<p>复合数据类型是基础数据类型的组合。Dart的复合数据类型包括：</p>
<ul>
<li><a href="ch01/dartpl0104.html#%E8%AE%B0%E5%BD%95record">记录 (Record)</a></li>
<li><a href="ch01/dartpl0104.html#%E6%9E%9A%E4%B8%BEenum">枚举（Enum)</a></li>
<li>列表（List, 数组）</li>
<li>集合（Set）</li>
<li>映射（Map）</li>
<li>类（class)</li>
</ul>
<p>Dart还有如下特殊的数据类型：</p>
<ul>
<li>函数（Function）</li>
<li><a href="ch01/dartpl0104.html#%E7%AC%A6%E5%8F%B7symbol">符号（Symbol)</a></li>
<li><code>null</code> 值 （空值，Null）</li>
</ul>
<p>第2章将讨论函数，第4章将讨论类，第6章将讨论列表（List）、集合（Set）、映射（Map）。</p>
<h2 id="数字"><a class="header" href="#数字">数字</a></h2>
<p>Dart的数字包括64-bit整数 int 和 64-bit浮点数 double。
int的取值范围为 -2<sup>63</sup>  至 to 2<sup>63</sup> -1。
double是双精度浮点数，遵循 IEEE 754 标准。</p>
<p>Dart是一门OOP编程语言，int和double是num的子类，因此它们有着一些共同的方法，例如:</p>
<ul>
<li>parse(string)</li>
<li>abs()</li>
<li>ceil()</li>
<li>toString()</li>
</ul>
<p>下面的代码声明了一个整数<code>radius</code> 和一个浮点数 <code>pi</code>：</p>
<pre><code class="language-dart">// ch0104_1.dart
void main() {
  int radius = 5;
  double pi = 3.1416;
  print('area: ${radius * radius * pi}'); 
  // Output: area=78.53999999999999
}
</code></pre>
<p>除了使用十进制书写整数外，还可以用十六进制。可以使用科学计数法书写浮点数。例如：</p>
<pre><code class="language-dart">// ch0104_2.dart
void main() {
  int radius = 0x10;
  double pi = 0.31416e1;
  print('radius=$radius area=${radius * radius * pi}');
  // Output: radius=16 area=804.2496
}
</code></pre>
<p>但是Dart并不直接支持书写八进制数。你可以用  octal 包来实现八进制的书写。</p>
<pre><code class="language-dart">// ch0104_3.dart
// dart pub add octal
import 'package:octal/octal.dart'; 

void main() {
  int decimalValue = octal(123); // 83 in decimal
  print(decimalValue); // Output: 83
  print(decimalValue.toRadixString(8)); // Output: 123
}
</code></pre>
<h2 id="字符串string"><a class="header" href="#字符串string">字符串（String）</a></h2>
<p>Dart中的String是一个UTF-16值的有序序列，写在一对单引号或双引号里。一个非常nice的功能是字符串插值，即在字符串里使用 <code>${expr}</code>  。</p>
<pre><code class="language-dart">// ch0104_4.dart
void main() {
  var str = "It's a beautiful day!";
  var str2 = 'It\'s a beautiful day!'; 
  print(str == str2); // Output: true

  var num = 5;
  print('There are $num apples.'); // Output: There are 5 apples.
  print('There are ${num + 2} oranges.'); // Output: There are 7 oranges.
}
</code></pre>
<p>上例中<code>str2</code> 写在一对单引号中，该行中的 <code>\</code> 为转义符，<code>\'</code>表示一个单引号。</p>
<p>两个字符串写在一起，中间可以使用一个<code>+</code>符号（但通常予以省略）， 就表示将这两个字符串顺序拼接在一起，形成一个新的字符串。因此对于多行文本，可以这样写：</p>
<pre><code class="language-dart">  // ch0104_5.dart
  var str =
      'A: Nice to meet you!\n'
      'B: Nice to meet you, too!';
</code></pre>
<p>这里的<code>\n</code>是换行符。书写多行文本更方便的做法是将文本写在一对三引号（<code>'''</code>或<code>"""</code>）中，例如：</p>
<pre><code class="language-dart">// ch0104_6.dart
void main() {
  var minAge = 18;
  var query =
      '''
SELECT id, name, age
FROM users
WHERE age &gt;= $minAge
''';
  print(query);
}
</code></pre>
<h2 id="布尔bool"><a class="header" href="#布尔bool">布尔（bool）</a></h2>
<p>布尔类型只有2个值，<code>true</code>和<code>false</code>，且它们都是编译时常量。</p>
<pre><code class="language-dart">// ch0104_7.dart
void main() {
  var isGreater = 43 &gt; 34;
  print('isGreater: $isGreater'); // Output: isGreater: true
  print('2 &lt; -3: ${2 &lt; -3}'); // Output: 2 &lt; -3: false
}
</code></pre>
<h2 id="符文rune"><a class="header" href="#符文rune">符文（Rune）</a></h2>
<p>符文代表unicode文字系统里的一个符号。unicode为世界上每一个文字或符号分配了一个数字，称之为code point。unicode 最多可支持 1,114,112 个code point，通过 17 个 16 位平面实现，每个平面可支持 65,536 个不同的code point。 unicode常见的编码方式（将code point映射为二进制数）有UTF-8、UTF-16和UTF-32。  Dart采用UTF-16编码，每个code unit为16位（2个字节），每个符文占用1个（0-65,535 code point）或2个code unit（65,536及以上)。对字符编码感兴趣的同学，请继续去了解下ASCII、UTF-8、UTF-16和UTF-32、GBK等。</p>
<p>Dart的String（字符串）本质上是code unit的序列。</p>
<pre><code class="language-dart">// ch0104_8.dart
void main() {
  var s = "笑\u7b11lol😆\u{1f606}"; // 1
  print(s); // 2 Output: 笑笑lol😆😆
  print('len: ${s.length}'); // 3 Output: len: 9

  print('code units: ${s.codeUnits}'); // 4
  // Output: code units: [31505, 31505, 108, 111, 108, 55357, 56838, 55357, 56838]

  print('runes: ${s.runes}'); // 5
  // Output: runes: (31505, 31505, 108, 111, 108, 128518, 128518)

  print(31505.toRadixString(16)); // 6 Output: 7b11
  print(128518.toRadixString(16)); // 7 Output: 1f606
}
</code></pre>
<ol>
<li>声明变量<code>s</code>，注意这里<code>\u7b11</code>就等于<code>笑</code>这个字符，<code>\uHHHH</code>表示<code>\u</code>后面是code point的十六进制表示<code>HHHH</code>；如果该十六进制数不是4位，就必须位于一堆花括号<code>{}</code>中，如<code>\u{1f606}</code>就等于😆这个emoji符号;</li>
<li>打印 <code>s</code>，从输出结果可以看出 <code>s</code>包含了7个符文（字符);</li>
<li>打印<code>s</code>的长度，结果为9, 可见是code unit的个数，下面一行代码印证了这一点；</li>
<li>代码<code>s</code>的code point 序列;</li>
<li>代码<code>s</code>的符文（字符）序列;</li>
<li>第6-7行代码分别显示31505和128518对应的十六进制表示，以方便分析。</li>
</ol>
<p>请仔细查看code units 与 runes 并进行对比，这将帮助你理解Rune（符文）和String（字符串）。</p>
<h3 id="使用-characters-包"><a class="header" href="#使用-characters-包">使用 <code>characters</code> 包</a></h3>
<p>下面这个示例同时演示了<code>characters</code>及<code>StringBuffer</code>类的使用。<code>characters</code> 为<code>String</code>类添加了一个扩展方法（第5章内容）<code>get characters</code>。<code>StringBuffer</code>是拼接字符串的高效方式。代码中使用的 for-each 循环将在下一章节介绍，这里先了解下。</p>
<pre><code class="language-dart">//ch0104_9.dart
//dart pub add characters
import 'package:characters/characters.dart';

void main() {
  const s = "笑一笑十年少😆"; // 1
  final sb = StringBuffer(); // 2 
  for (var ch in s.characters) { // 3
    sb.write(ch);
    sb.write(' ');
  }
  print(sb);
}

</code></pre>
<h2 id="记录record"><a class="header" href="#记录record">记录（Record）</a></h2>
<p>Dart 3.0 引入了记录这一数据类型。记录是匿名的、不可变的聚合类型，是异质数据的集合。</p>
<pre><code class="language-dart">// ch0104_a.dart
void main() {
  var record = ('class 1', name: 'Alice', id: 1, 'good student'); // 1
  print(record); // 2 Output: (class 1, good student, id: 1, name: Alice)
  print(record.$1); // 3 Output: class 1
  print(record.$2); // Output: good student
  print(record.id); // 4 Ouput: 1
  print(record.name); // Output: Alice

  // record.id = 2; // 5
  // Error: The setter 'id' isn't defined for the class '(String, String, {int id, String name})'.
  // Try correcting the name to the name of an existing setter, or defining a setter or field named 'id'.
  //   record.id = 2;
  //          ^^
}
</code></pre>
<ol>
<li>声明一个变量<code>record</code>并赋值，如你所见，记录有位置字段和命名字段（如这里的<code>id</code>和<code>name</code>）;</li>
<li>打印 <code>record</code>，注意观察字段的显示顺序;</li>
<li>打印 <code>record</code> 的第1个位置字段<code>record.$1</code> ;</li>
<li>打印 <code>record</code> 的命名字段 <code>record.id</code>;</li>
<li>修改 <code>record</code> 的<code>id</code>，遭遇编译错误，这说明了记录是不可变的，同时从错误信息中可以看出，记录是一种特殊的匿名类。</li>
</ol>
<h3 id="记录类型"><a class="header" href="#记录类型">记录类型</a></h3>
<p>记录（Record）没有明确的类型声明，因为它是匿名的，但记录是有形状（Shaple）的。本例中 <code>record</code>的形状为<code>(String, String, {int id, String name})</code>；在一对花括号(<code>{}</code>)里的<code>int id, String name</code> 为命名字段 <code>id</code>与<code>name</code>，其类型分别为<code>int</code>与<code>String</code>；没有花括号包围的便是位置字段。</p>
<pre><code class="language-dart">// ch01004_b.dart
void main() {
  (int x, int y, int z) point = (1, 2, 3);
  var color = (1, 2, 3);
  print(point); // Output: (1, 2, 3)
  print(point == color); // Output: true

  ({int x, int y, int z}) point2 = (x: 1, y: 2, z: 3);
  var color2 = (r: 1, g: 2, b: 3);
  print(point2); // Output: (x: 1, y: 2, z: 3)
  print(color2); // Output: (b: 3, g: 2, r: 1)
  print(point2 == color2); // Output: false
}
</code></pre>
<p><code>point</code> 与 <code>color</code>具有相同的形状和值，因此他们是相等的，而<code>point2</code> 与 <code>color2</code>的形状不同，自然就不相等。</p>
<h3 id="解构与变量交换"><a class="header" href="#解构与变量交换">解构与变量交换</a></h3>
<p>记录的解构与变量交换非常实用。</p>
<pre><code class="language-dart">// ch0104_c.dart
void main() {
  var (x, y) = (1, 2); // 1
  print('x=$x y=$y'); // Output: x=1 y=2

  (y, x) = (x, y); // 2
  print('x=$x y=$y'); // Output: x=2 y=1

  var (:name, :age) = (name: 'Bob', age: 20); // 3
  print('name=$name b=$age'); // Output: name=Bob b=20

  var (x: a, y: b) = (x: 3, y: 4); // 4
  print('a=$a b=$b'); // Output: a=3 b=4
  
  var (who, _, :nickname, fav: _) = (
    'Robert',
    'Naughty boy',
    nickname: 'Bob',
    fav: 'play the guitar',
  ); // 5
  print('who=$who nickname=$nickname'); // Output: who=Robert nickname=Bob
}
</code></pre>
<ol>
<li>解构记录<code>(1,2)</code>至局部变量<code>x</code>和<code>y</code>，这里使用了模式匹配（第3章内容）;</li>
<li>交换<code>x</code>和<code>y</code>的值;</li>
<li>使用冒号（<code>:</code>）语法，解构命名记录<code> (name: 'Bob', age: 20)</code>至局部变量<code>name</code>和<code>age</code> ;</li>
<li>解构命名记录<code>  (x: 3, y: 4)</code>至局部变量<code>a</code>和<code>b</code> ;</li>
<li>这是一个综合例子，请运用已学知识自行分析。</li>
</ol>
<h2 id="枚举enum"><a class="header" href="#枚举enum">枚举（Enum）</a></h2>
<p>枚举是一种用于表示固定数量的常量值的特殊类。使用关键字<code>enum</code>声明个一个枚举。</p>
<pre><code class="language-dart">// ch0104_d.dart
enum Color { red, green, blue }

void main() {
  print(Color.red); // Output: Color.red
  print(Color.blue.name); // Output: blue
  print(Color.blue.index); // Output: 2
}
</code></pre>
<p>每个枚举值都有个与之关联的数字，称之为<code>index</code>，该数字从0开始。枚举是一种特殊的类，因此它也可以定义字段（实例变量）和方法，只不过有一些限制，例如枚举的实例变量必须声明为<code>final</code>。第4章会更详细地讨论枚举。</p>
<h2 id="符号symbol"><a class="header" href="#符号symbol">符号（Symbol)</a></h2>
<p>符号对象表示 Dart 程序中声明的操作符或标识符。一般极少用到，在此了解即可。</p>
<pre><code class="language-dart">// ch0104_e.dart
void main() {
  print(#foo); // Output: Symbol("foo")
}
</code></pre>
<h2 id="typedef"><a class="header" href="#typedef">typedef</a></h2>
<p>用<code>typedef</code>关键字为数据类型取一个别名。</p>
<pre><code class="language-dart">//ch0104_f.dart
typedef Point = ({int x, int y});
typedef VoidCallback = void Function();
typedef IntList = List&lt;int&gt;;

void main() {
  Point p = (x: 1, y: 2);
  IntList nums = [3, 4, 5];
}

</code></pre>
<h2 id="小测验"><a class="header" href="#小测验">小测验</a></h2>
<p>以下程序的输出是什么?</p>
<pre><code class="language-dart">// ch01004_quiz.dart
void main() {
  var point = (x: 1, y: 2, z: 3);
  ({num x, int y, int z}) point2 = (x: 1, y: 2, z: 3);
  print(point == point2);
}
</code></pre>
<h2 id="参考资料-3"><a class="header" href="#参考资料-3">参考资料</a></h2>
<ul>
<li><a href="https://dart.dev/language/built-in-types">https://dart.dev/language/built-in-types</a></li>
<li><a href="https://pub.dev/documentation/octal/latest/">https://pub.dev/documentation/octal/latest/</a></li>
<li><a href="https://docs.oracle.com/cd/E19253-01/817-2521/overview-207/index.html">Unicode Overview</a></li>
<li><a href="https://dart.dev/language/records">https://dart.dev/language/records</a></li>
<li><a href="https://dart.dev/language/enums">https://dart.dev/language/enums</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="操作符"><a class="header" href="#操作符">操作符</a></h1>
<p>计算机程序的表达式由操作符和操作数构成。如<code>1+2</code>这个表达式中，<code>+</code>是操作符，数字<code>1</code>和<code>2</code>是操作数。如果表达式中只有一个操作数，它便是一元表达式；如果有两个操作数，它便是二元表达式；类似地还有三元表达式。一元表达式中的操作符为一元操作符。</p>
<p>Dart提供了非常丰富的操作符，且支持为类（class，第4-5章内容）定义操作符。</p>
<ul>
<li><a href="ch01/dartpl0105.html#%E7%AE%97%E6%9C%AF%E6%93%8D%E4%BD%9C%E7%AC%A6">算术操作符</a></li>
<li><a href="ch01/dartpl0105.html#%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C%E7%AC%A6">关系操作符</a></li>
<li><a href="ch01/dartpl0105.html#%E7%B1%BB%E5%9E%8B%E6%B5%8B%E8%AF%95%E6%93%8D%E4%BD%9C%E7%AC%A6">类型测试操作符</a></li>
<li><a href="ch01/dartpl0105.html#%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6">赋值操作符</a></li>
<li><a href="ch01/dartpl0105.html#%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6">逻辑操作符</a></li>
<li><a href="ch01/dartpl0105.html#%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6">位操作符</a></li>
<li><a href="ch01/dartpl0105.html#%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F">条件表达式</a></li>
<li><a href="ch01/dartpl0105.html#%E7%BA%A7%E8%81%94%E7%AC%A6%E5%8F%B7">级联符号</a></li>
<li><a href="ch01/dartpl0105.html#%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C%E7%AC%A6">其他操作符</a></li>
</ul>
<h2 id="算术操作符"><a class="header" href="#算术操作符">算术操作符</a></h2>
<div class="table-wrapper"><table><thead><tr><th>操作符</th><th>含义</th><th>示例</th></tr></thead><tbody>
<tr><td><code>+</code></td><td>加</td><td><code>1 + 2</code>  <span class="hljs-comment"> <em>//3</em></span></td></tr>
<tr><td><code>-</code></td><td>减</td><td><code>4 - 3</code>  <span class="hljs-comment">  <em>//1</em></span></td></tr>
<tr><td><code>-</code><span class="hljs"><em>expr</em></span></td><td>符号取反</td><td><code>-x</code></td></tr>
<tr><td><code>*</code></td><td>乘</td><td><code>3 * 5</code>  <span class="hljs-comment"> <em>//15</em></span></td></tr>
<tr><td><code>/</code></td><td>除，结果是一个浮点数</td><td><code>7 / 2</code>  <span class="hljs-comment">  <em>//3.5</em></span></td></tr>
<tr><td><code>~/</code></td><td>整除，除法的整数部分，结果是一个整数</td><td><code>7 ~/ 2</code>  <span class="hljs-comment">  <em>//3</em></span></td></tr>
<tr><td><code>%</code></td><td>模，除法的余数部分，结果是一个整数或浮点数</td><td><code>7 % 2</code>  <span class="hljs-comment">  <em>//1</em></span></td></tr>
</tbody></table>
</div>
<p>Dart支持自增（<code>++</code>）与自减（<code>--</code>）一元操作符。表达式<code>x++</code> 相当于<code>x = x+1</code>，<code>x--</code> 相当于<code>x = x-1</code>。 这两个操作符位于操作数之前或之后均可，但有区别。</p>
<pre><code class="language-dart">// ch0105_1.dart
void main() {
  var x = 3, y = 3;
  print('${x++} $x'); // Output: 3 4
  print('${++y} $y'); // Output: 4 4
}
</code></pre>
<p>表达式<code>x++</code> 的值为<code>x</code>，先返回<code>x</code>，再将<code>x</code>自增1；而表达式<code>++x</code>的值为<code>x+1</code>，也就是先将<code>x</code>自增1，再返回<code>x</code>。
我们用同样的方式去理解<code>x--</code> 与<code>--x</code>。</p>
<h2 id="关系操作符"><a class="header" href="#关系操作符">关系操作符</a></h2>
<p>关系操作符用于布尔表达式（其结果为<code>true</code>或<code>false</code>）。</p>
<div class="table-wrapper"><table><thead><tr><th>操作符</th><th>含义</th><th>示例</th></tr></thead><tbody>
<tr><td><code>==</code></td><td>等于</td><td><code>5 == 5</code></td></tr>
<tr><td><code>!=</code></td><td>不等于</td><td><code>6 != 7</code></td></tr>
<tr><td><code>&gt;</code></td><td>大于</td><td><code>8 &gt; 7</code></td></tr>
<tr><td><code>&lt;</code></td><td>小于</td><td><code>6 &lt; 9</code></td></tr>
<tr><td><code>&gt;=</code></td><td>大于等于</td><td><code>4 &gt;= 3</code></td></tr>
<tr><td><code>&lt;=</code></td><td>小于等于</td><td><code>3 &lt;= 4</code></td></tr>
</tbody></table>
</div>
<p>关于<code>==</code> 操作符：</p>
<ol>
<li>如果 <code>x</code> 或 <code>y</code> 为 <code>null</code>，则只有当它们都是 <code>null</code>，<code>x==y</code> 才返回 <code>true</code>；如果只有一个为 <code>null</code>，则<code>x==y</code> 返回 <code>false</code>。</li>
<li><code>x == y</code>本质上是调用 <code>x</code>的<code>==</code> 操作符方法（以<code>y</code>作为参数），然后返回其结果， 类似于 <code>x.equals(y)</code> 。</li>
<li>极少情况下，你需要知道<code>x</code>和<code>y</code>是否引用了同一个对象，使用<code>identical(x,y)</code>。</li>
</ol>
<blockquote>
<p><strong><em>NOTE:</em></strong> 方法、对象的概念将在第4章介绍。</p>
</blockquote>
<h2 id="类型测试操作符"><a class="header" href="#类型测试操作符">类型测试操作符</a></h2>
<p><code>as</code>、<code>is</code> 和 <code>is!</code> 操作符用于在运行时检查类型。</p>
<div class="table-wrapper"><table><thead><tr><th>操作符</th><th>含义</th><th>示例</th></tr></thead><tbody>
<tr><td><code>as</code></td><td>类型转换（该符号也用于<code>import</code>语句中给包取别名）</td><td><code>obj as String</code></td></tr>
<tr><td><code>is</code></td><td>如果对象具有指定类型返回<code>true</code></td><td><code>obj is double</code></td></tr>
<tr><td><code>is!</code></td><td>如果对象不具有指定类型返回<code>true</code></td><td><code>obj is! num</code></td></tr>
</tbody></table>
</div>
<h2 id="赋值操作符"><a class="header" href="#赋值操作符">赋值操作符</a></h2>
<p>首先来看 <code>=</code> 和 <code>??=</code> 这两个赋值操作符。</p>
<div class="table-wrapper"><table><thead><tr><th>操作符</th><th>含义</th><th>示例</th></tr></thead><tbody>
<tr><td><code>=</code></td><td>赋值</td><td><code>x = 123;</code></td></tr>
<tr><td><code>??=</code></td><td>仅当变量为<code>null</code>才对其赋值</td><td><code> x ??= 234;</code></td></tr>
</tbody></table>
</div>
<p>复合赋值操作符组合了一个操作和赋值，以 <code>+=</code> 为例，<code> x += y</code> 就等价于 <code> x = x + y</code>。假设  <code>op</code> 是一个操作符，那么 <code>a op= b</code> 等价于  <code> a = a op b</code>。以下是复合赋值操作符：</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody>
<tr><td><code>*=</code></td><td><code>%=</code></td><td><code>&gt;&gt;&gt;=</code></td><td><code>^=</code></td></tr>
<tr><td><code>+=</code></td><td><code>/=</code></td><td><code>&lt;&lt;=</code></td><td><code>&amp;=</code></td></tr>
<tr><td><code>|=</code></td><td><code>-=</code></td><td><code>~/=</code></td><td><code>&gt;&gt;=</code></td></tr>
</tbody></table>
</div>
<h2 id="逻辑操作符"><a class="header" href="#逻辑操作符">逻辑操作符</a></h2>
<p>您使用逻辑运算符反转或组合布尔表达式。</p>
<div class="table-wrapper"><table><thead><tr><th>操作符</th><th>含义</th><th>示例</th></tr></thead><tbody>
<tr><td><code>!</code><span class="hljs"><em>expr</em></span></td><td>逻辑非，逻辑取反</td><td><code>!x</code></td></tr>
<tr><td><code>||</code></td><td>逻辑或（OR）</td><td><code>x == 3 || x ==4</code></td></tr>
<tr><td><code>&amp;&amp;</code></td><td>逻辑与（AND）</td><td><code> x &gt;=1 &amp;&amp;  y &lt; 6</code></td></tr>
</tbody></table>
</div>
<p>下面是一个稍微复杂的例子：</p>
<pre><code class="language-dart">if (ok &amp;&amp; (x &lt; 5 || y &gt; 6)) {
    print('good');
}
</code></pre>
<h2 id="位操作符"><a class="header" href="#位操作符">位操作符</a></h2>
<p>Dart可以对数字的每一位（bit）进行操作。</p>
<div class="table-wrapper"><table><thead><tr><th>操作符</th><th>含义</th><th>示例</th></tr></thead><tbody>
<tr><td><code>&amp;</code></td><td>与（AND）</td><td><code> 1 &amp; 2</code> <span class="hljs-comment">  <em>//0</em></span></td></tr>
<tr><td><code>|</code></td><td>或（OR）</td><td><code>1 | 2</code><span class="hljs-comment">  <em>//3</em></span></td></tr>
<tr><td><code>^</code></td><td>异或（XOR）</td><td><code>2 ^ 3</code><span class="hljs-comment">  <em>//1</em></span></td></tr>
<tr><td><code>~</code><span class="hljs"><em>expr</em></span></td><td>按位补码（0变为1，1变为0）</td><td><code>～1</code><span class="hljs-comment">  <em>//-2</em></span></td></tr>
<tr><td><code>&lt;&lt;</code></td><td>左移位</td><td><code>1 &lt;&lt; 10</code><span class="hljs-comment">  <em>//1024</em></span></td></tr>
<tr><td><code>&gt;&gt;</code></td><td>右移位</td><td><code>1024 &gt;&gt; 9</code><span class="hljs-comment">  <em>//2</em></span></td></tr>
<tr><td><code>&gt;&gt;&gt;</code></td><td>无符号右移</td><td><code>-1 &gt;&gt;&gt; 61</code><span class="hljs-comment">  <em>//7</em></span></td></tr>
</tbody></table>
</div>
<h2 id="条件表达式"><a class="header" href="#条件表达式">条件表达式</a></h2>
<p>先来看下面的代码片段:</p>
<pre><code class="language-dart">  int n;
  if (x &lt; 3) {
    n = 3;
  } else {
    n = x;
  }
</code></pre>
<p>上面计算<code>n</code> 的代码，用条件表达式就简化为:</p>
<pre><code class="language-dart">  var n = x &lt; 3 ? 3 : x;
</code></pre>
<p>条件表达式 <code>condition  ?  expr1  :  expr2</code> ，有 <code>?</code>和<code>:</code>2个操作符，<code>?</code>之前为一个表示条件的布尔表达式<code>condition</code>；如果<code>condition</code>的值为<code>true</code>，该表达式的值就取<code>expr1</code>的值，否则取 <code>expr2</code>的值。</p>
<h2 id="级联符号"><a class="header" href="#级联符号">级联符号</a></h2>
<p>Dart的级联符号（<code>..</code> 和 <code>?..</code>）用于对同一个对象进行一系列操作。下面的代码片段：</p>
<pre><code class="language-dart">  var sb = StringBuffer();
  sb.write('Hello ');
  sb.write('Dart');
  sb.write('!');
  print(sb);
</code></pre>
<p>用级联符号就简化为:</p>
<pre><code class="language-dart">  print(
    StringBuffer()
      ..write('Hello ')
      ..write('Dart')
      ..write('!'),
  );
</code></pre>
<p><code>?..</code> 与 <code>..</code>类似，只不过用于nullable对象的第一个操作。</p>
<pre><code class="language-dart">  sb2
    ?..write('Hello ')
    ..write('Dart')
    ..write('!');
</code></pre>
<p>上面代码中的<code>sb2</code>如果是<code>null</code>，就不会执行任何的级联操作。</p>
<h2 id="其他操作符"><a class="header" href="#其他操作符">其他操作符</a></h2>
<p>下面的操作符已在前面章节介绍过，不再赘述。</p>
<div class="table-wrapper"><table><thead><tr><th>操作符</th><th>含义</th><th>示例</th></tr></thead><tbody>
<tr><td><code>()</code></td><td>函数调用</td><td><code>doIt()</code></td></tr>
<tr><td><code>[]</code></td><td>下标访问</td><td><code>todoList[0]</code></td></tr>
<tr><td><code>?[]</code></td><td>有条件下标访问</td><td><code>fruits?[0]</code></td></tr>
<tr><td><code>.</code></td><td>成员访问</td><td><code>point.x</code></td></tr>
<tr><td><code>?.</code></td><td>有条件成员访问</td><td><code>point?.x</code></td></tr>
<tr><td><code>!</code></td><td>非空断言</td><td><code>point!</code></td></tr>
<tr><td><code>...</code></td><td>展开一个集合（collection），插入另一个集合（collection）</td><td><code>...myList</code></td></tr>
<tr><td><code>...?</code></td><td>与<code>...</code>类似，适用于nullable对象</td><td><code>....?anotherList</code></td></tr>
</tbody></table>
</div>
<h2 id="参考资料-4"><a class="header" href="#参考资料-4">参考资料</a></h2>
<ul>
<li><a href="https://dart.dev/language/operators">https://dart.dev/language/operators</a></li>
<li><a href="https://dart.dev/language/methods#operators">https://dart.dev/language/methods#operators</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="注释"><a class="header" href="#注释">注释</a></h1>
<p>代码中的注释帮助人们阅读代码，文档注释还用于生成API（应用编程接口）文档。Dart 支持三种注释：</p>
<ul>
<li><a href="ch01/dartpl0106.html#%E5%8D%95%E8%A1%8C%E6%B3%A8%E9%87%8A">单行注释</a></li>
<li><a href="ch01/dartpl0106.html#%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A">多行注释</a></li>
<li><a href="ch01/dartpl0106.html#%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A">文档注释</a></li>
</ul>
<p>单行注释和多行注释会被编译器忽略，而文档注释可用于Dart的文档生成工具，<code>dart doc</code>。</p>
<h2 id="单行注释"><a class="header" href="#单行注释">单行注释</a></h2>
<p>单行注释以<code>//</code>开头，从<code>//</code>到这一行的末尾，都会被Dart编译器忽略。</p>
<pre><code class="language-dart">  // This line will be ignored by Dart compiler
  print('Hello');
</code></pre>
<h2 id="多行注释"><a class="header" href="#多行注释">多行注释</a></h2>
<p>多行注释以 <code>/*</code> 开头，以<code>*/</code> 结尾。</p>
<pre><code class="language-dart">  /*
  This whole paragraph will be ignored by Dart compiler.
  Greetings to Dart.
  */
  print("Hello Dart!");
</code></pre>
<h2 id="文档注释"><a class="header" href="#文档注释">文档注释</a></h2>
<p>文档注释以<code>///</code>开头（单行文档注释），或以<code>/**</code>开始以<code>*/</code>结束（多行文档注释）。在连续的行上使用 <code>///</code> 与多行文档注释具有相同的效果。</p>
<pre><code class="language-dart">// lib/ch0106_2.dart

/// A student class encapsulate student information,
/// including id, name and birthdate.
/// 
/// This class is immutable.
class Student {
  final int id;
  final String name;
  final DateTime birthdate;
  const Student(this.id, this.name, this.birthdate);
}
</code></pre>
<h2 id="参考资料-5"><a class="header" href="#参考资料-5">参考资料</a></h2>
<ul>
<li><a href="https://dart.dev/language/comments">https://dart.dev/language/comments</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if-与-switch-语句"><a class="header" href="#if-与-switch-语句">if 与 switch 语句</a></h1>
<p>程序的控制结构包括：</p>
<ul>
<li>顺序（顺序执行）</li>
<li>分支（<code>if</code>、<code>switch</code>）</li>
<li>循环（<code>for</code>、<code>while</code>）</li>
</ul>
<p>分支语句包括 <code>if</code> 和 <code>switch</code>语句。</p>
<h2 id="if"><a class="header" href="#if"><code>if</code></a></h2>
<p>下例中，如果 <code>isSunny</code>的值为<code>true</code>，就执行打印，否则什么也不做。</p>
<pre><code class="language-dart">// ch0201_1.dart
import 'dart:math';

void main() {
  final rand = Random();
  final isSunny = rand.nextInt(10) % 2 == 0;
  if (isSunny) {
    print("Let's go to the park");
  }
}  
</code></pre>
<pre class="mermaid">flowchart TD
    B{条件}--&gt;|true| C(代码块)
    C --&gt; E([End])
    B --&gt;|false| E
</pre>
<p><code>if</code> 有一个可选的<code>else</code>分支。</p>
<pre><code class="language-dart">  if (isSunny) {
    print("Let's go to the park");
  } else {
    print("It's not sunny");
  }
</code></pre>
<pre class="mermaid">flowchart TD
    B{条件}--&gt;|true| C(主分支)
    C --&gt; E([End])
    B --&gt;|false| D(else分支)
    D --&gt; E
</pre>
<p>还可以使用 <code>else if</code>，像下面这样。</p>
<pre><code class="language-dart">  if (isSunny) {
    print("Let's go to the park");
  } else if (isRaining) {
    print("Let's bring our raincoats");
  } else {
    print("Let's stay home");
  }
</code></pre>
<p>从语法上讲，上例中最后的<code>else</code>分支也是可选的。</p>
<h3 id="if-case"><a class="header" href="#if-case">if-case</a></h3>
<p>从 Dart 3.0 开始， <code>if</code> 语句支持 <code>case</code> 子句，<code>case</code>后面接一个模式（pattern，第3章内容）。</p>
<pre><code class="language-dart">// ch0201_2.dart
void main() {
  var dat = [1, 2]; 
  if (dat case [_, _]) { // 1
    print('matched'); // 2
  } else {
    print('not matched'); // 2a
  }

  if (dat case [int x, int y]) { // 3
    print('x=$x y=$y'); // 4
  }
}

</code></pre>
<ol>
<li>使用 if-case 检查 <code>dat</code>  是否匹配一个包含2个元素的列表;</li>
<li>如果匹配，就打印字符串 <code>"matched"</code>，否则打印<code>"not matched"</code> (2a);</li>
<li>使用 if-case 将  <code>dat</code>与列表进行匹配，并捕获列表中的元素。</li>
</ol>
<h2 id="switch"><a class="header" href="#switch"><code>switch</code></a></h2>
<p>如果需要匹配多个case，应使用<code>switch</code> 语句，而非一个又一个的<code>else if</code>。</p>
<pre class="mermaid">flowchart TD
    A{switch}--&gt;|case1| B(case1)
    A --&gt; |case2| C(case2)
    A --&gt; |case...| D(case...)
    A --&gt; |default| E(default分支)
    B --&gt; Z([End])
    C --&gt; Z
    D --&gt; Z
    E --&gt; Z
</pre>
<pre><code class="language-dart">// ch0201_3.dart
void main() {
  var status = 'done';
  switch (status) {
    case 'done':
      print('done');
    case 'ongoing':
      print('ongoing');
    case 'pending':
      print('pending');
    default: // case _:
      print('unknown status: $status');
  }
}
</code></pre>
<p>如果其他case都不匹配，则执行default case的代码，也就是 <code>default</code>  或 <code>case _</code>  标记的代码 。default case 要放在最后。</p>
<h3 id="fallthrough-与-标签lablel"><a class="header" href="#fallthrough-与-标签lablel">fallthrough 与 标签（lablel）</a></h3>
<p>空case（empty case）是指不做任何处理的case。默认情况下空case会fall through到下一个case，使得cases可以共享代码块。如果想让空case fall through到其他的case（非下一个case），使用标签（label）和 <code>continue</code>来实现。</p>
<pre><code class="language-dart">// ch0201_4.dart
void main() {
  var status = 'canceled';
  switch (status) {
    case 'canceled': // 1 empty case
    case 'done': // 1a
      print('done');
    todo: // 2
    case 'todo':
      print('todo');
    case 'pending':
      print('pending');
      continue todo; // 3
    case 'ongoing':
      print('ongoing');
    case _:
      print('unknown status: $status');
  }
}
</code></pre>
<ol>
<li>这是一个空case（ <code>canceled</code> ），它没有对应的代码块，fall through 到下一个case（<code>done</code> ）， 这两个case共享了代码块（<code>print('done')</code>） ; 此外这两个case也可以写成</li>
</ol>
<pre><code class="language-dart">    case 'canceled' || 'done':
      print('done');
</code></pre>
<ol start="2">
<li>这里定义了一个标签 <code>todo</code>；</li>
<li>在执行完上一行代码后（<code>print('pending')</code>），跳转至 <code>todo</code> 标签所在位置继续执行（<code> print('todo')</code>）。</li>
</ol>
<p>如果不想让空case fall through， 使用  <code>break</code> 即可。</p>
<pre><code class="language-dart">    case 'canceled':
      break;
</code></pre>
<h3 id="switch-表达式"><a class="header" href="#switch-表达式"><code>switch</code> 表达式</a></h3>
<p><code>switch</code>表达式将返回一个值，这个值来自于匹配的case的表达式。先来看一个普通的switch语句：</p>
<pre><code class="language-dart">// ch0201_5.dart
void main() {
  var x = 1.0, y = 2.0;
  var op = '+';
  double r;
  switch (op) {
    case '+':
      r = x + y;
    case '-':
      r = x - y;
    case '*':
      r = x * y;
    case '/':
      r = x / y;
    case '%':
      r = x % y;
    case _:
      throw 'unknown op: $op';
  }
  print('$x$op$y=$r');
}
</code></pre>
<p>用<code>switch</code>表达式改写：</p>
<pre><code class="language-dart">// ch0201_6.dart
void main() {
  var x = 1.0, y = 2.0;
  var op = '+';
  var r = switch (op) {
    '+' =&gt; x + y,
    '-' =&gt; x - y,
    '*' =&gt; x * y,
    '/' =&gt; x / y,
    '%' =&gt; x % y,
    _ =&gt; throw 'unknown op: $op',
  };
  print('$x$op$y=$r');
}
</code></pre>
<p>在语法方面，与<code>switch</code> 语句相比，<code>switch</code>表达式：</p>
<ol>
<li>case不以 <code>case</code> 关键字开头;</li>
<li>case主体是一个单一的表达式，而不是一系列的语句;</li>
<li>每个case都必须有一个主体；对于空case，没有隐式的 fallthrough;</li>
<li>case模式与其主体使用 <code>=&gt;</code> 而不是 <code>:</code> 分隔;</li>
<li>各个case之间用 <code>,</code> 分隔（允许在结尾添加可选的<code> ,</code> ）;</li>
<li>default case 只能用 <code>_</code>， 无法用<code>default</code>。</li>
</ol>
<h3 id="详尽性检查"><a class="header" href="#详尽性检查">详尽性检查</a></h3>
<p>下面这段代码将引起编译错误：</p>
<pre><code class="language-dart">//ch0201_7.dart
void main() {
  bool? win;
  var score = switch (win) {
    true =&gt; 2,
    false =&gt; 0,
  };
  // Error: The type 'bool?' is not exhaustively matched by the switch cases since it doesn't match 'null'.
  // Try adding a wildcard pattern or cases that match 'null'.
  //   var score = switch (win) {
  //                       ^
}
</code></pre>
<p>对于一个 <code>boo?</code>类型的变量，它的值是穷举的，即 <code>true</code>、<code>false</code>和 <code>null</code>，Dart编译器将对这类可穷举类型的变量进行详尽性检查。上例的编译错误告诉我们缺少了对 <code>null</code> case 的处理。常见的可穷举类型还有<code>bool</code>、枚举（Enum）和<a href="https://dart.dev/language/class-modifiers#sealed">密封类（sealed class）</a>。</p>
<p>下例演示了针对枚举的详尽性检查。</p>
<pre><code class="language-dart">// ch0201_8.dart
void main() {
  var x = 1.0, y = 2.0;
  var op = Op.plus;
  var r = switch (op) {
    Op.plus =&gt; x + y,
    // Op.minus =&gt; x - y,
  };
  // Error: The type 'Op' is not exhaustively matched by the switch cases since it doesn't match 'Op.minus'.
  //  - 'Op' is from 'bin/ch02/ch0201_8.dart'.
  // Try adding a wildcard pattern or cases that match 'Op.minus'.
  //   var r = switch (op) {
  //                   ^
}

enum Op { plus, minus }
</code></pre>
<p>下例演示了针对密封类的详尽性检查。一个<a href="https://dart.dev/language/class-modifiers#sealed">密封类</a>的子类是有限个的，<code>switch</code>语句或表达式将对其子类进行详尽性检查。</p>
<pre><code class="language-dart">// ch0201_9.dart
void main() {
  Op op = Plus(1.0, 2.0);
  var r = switch (op) {
    Plus(:double x, :double y) =&gt; x + y,
    // Minus(:double x, :double y) =&gt; x - y,
  };
  // Error: The type 'Op' is not exhaustively matched by the switch cases since it doesn't match 'Minus()'.
  //  - 'Op' is from 'bin/ch02/ch0201_9.dart'.
  // Try adding a wildcard pattern or cases that match 'Minus()'.
  //   var r = switch (op) {
  //                   ^
}

sealed class Op {
  final double x;
  final double y;

  Op(this.x, this.y);
}

class Plus extends Op {
  Plus(super.x, super.y);
}

class Minus extends Op {
  Minus(super.x, super.y);
}
</code></pre>
<p>第4-5章将详细讨论类的相关概念。</p>
<h2 id="守护子句"><a class="header" href="#守护子句">守护子句</a></h2>
<p>守护子句（guard clause）是可选的，它出现在case子句之后，使用关键字 <code>when</code>。守护子句可以出现在 if-case 以及 <code>switch</code> 语句和表达式中。</p>
<pre><code class="language-dart">// ch0201_a.dart
void main() {
  var year = 2025;
  bool showAges = true;
  switch (year) {
    case &gt;= 2000 when showAges &amp;&amp; year &lt; 2010:
      print('2000s');
    case &gt;= 2010 when showAges &amp;&amp; year &lt; 2020:
      print('2010s');
    case &gt;= 2020 when showAges &amp;&amp; year &lt; 2030:
      print('2020s');
  }

  var dat = [3, 4];
  if (dat case [int x, int y] when x &lt; y) {
    print('x=$x y=$y');
  }
}
</code></pre>
<h2 id="参考资料-6"><a class="header" href="#参考资料-6">参考资料</a></h2>
<ul>
<li><a href="https://dart.dev/language/branches">https://dart.dev/language/branches</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="for-与-while-循环"><a class="header" href="#for-与-while-循环">for 与 while 循环</a></h1>
<p>控制结构里的循环指的是重复执行一段代码，直到循环条件不再满足，或使用<code>break</code>关键字跳出循环。Dart控制结构里的循环包括：</p>
<ul>
<li>经典 <code>for</code> 循环</li>
<li><code>for-in</code> 循环</li>
<li><code>while</code> 循环</li>
<li><code>do-while</code>循环</li>
</ul>
<h2 id="for-循环"><a class="header" href="#for-循环"><code>for</code> 循环</a></h2>
<p>下面这段代码使用经典的<code>for</code>循环打印数字0到9。</p>
<pre><code class="language-dart">// ch0202_1.dart
void main() {
  for (var i = 0; i &lt; 10; i++) {
    print('$i');
  }
}
</code></pre>
<p>经典<code>for</code>循环的语法:</p>
<pre><code class="language-dart">  for (初始化列表; 循环条件; 后置操作) {
    循环体
  }
</code></pre>
<pre class="mermaid">flowchart TD
    A([初始化列表]) --&gt; B{循环条件}
    B --&gt;|true| C(循环体)
    C --&gt;|continue| D(后置操作)
    D --&gt; B
    B ----&gt;|false| E([End])
    C ----&gt;|break| E
</pre>
<p>后置操作即执行完循环体之后的操作。初始化列表、 循环条件、后置操作，这三部分用分号（<code>;</code>）分割，且每一部分都可以省略（但必须保留分号）。如果循环体只有一条语句，包围循环体的那对花括号（<code>{}</code>） 可以省略，但不建议这么做。</p>
<p>下面这段代码将打印九九乘法表：</p>
<pre><code class="language-dart">// ch0202_2.dart
import 'dart:io';

import 'package:sprintf/sprintf.dart';

void main() {
  for (var i = 1; i &lt; 10; i++) {
    for (var j = 1; j &lt; 10; j++) {
      stdout.write(sprintf('%2d ', [i * j]));
    }
    stdout.write('\n');
  }
}
</code></pre>
<p>下面这段代码将数字10分解为2个非负整数之和：</p>
<pre><code class="language-dart">// ch0202_3.dart
void main() {
  for (var i = 0, j = 10; i &lt;= j; i++, j--) {
    print('$i + $j = 10');
  }
  // Output:
  // 0 + 10 = 10
  // 1 + 9 = 10
  // 2 + 8 = 10
  // 3 + 7 = 10
  // 4 + 6 = 10
  // 5 + 5 = 10
}
</code></pre>
<p>下面这段代码的功能一样，但省略了循环条件 <code>i &lt;= j</code>， 改用<code>break</code>语句来跳出循环：</p>
<pre><code class="language-dart">// ch0202_4.dart
void main() {
  for (var i = 0, j = 10; ; i++, j--) {
    if (i &gt; j) break;
    print('$i + $j = 10');
  }
}
</code></pre>
<h3 id="for-in"><a class="header" href="#for-in"><code>for-in</code></a></h3>
<p>使用经典的<code>for</code>语句打印字母A-E：</p>
<pre><code class="language-dart">// ch0202_5.dart
import 'dart:io';

void main() {
  var letters = ['A', 'B', 'C', 'D', 'E'];
  for (var i = 0; i &lt; letters.length; i++) {
    stdout.write('${letters[i]} '); // Output: A B C D E
  }
}
</code></pre>
<p>使用 for-in语句改写上述代码，更为简洁：</p>
<pre><code class="language-dart">// ch0202_6.dart
import 'dart:io';

void main() {
  var letters = ['A', 'B', 'C', 'D', 'E'];
  for (var letter in letters) {
    stdout.write('$letter '); // Output: A B C D E
  }
}
</code></pre>
<h2 id="while-和-do-while"><a class="header" href="#while-和-do-while"><code>while</code> 和 <code>do-while</code></a></h2>
<p><code>while</code> 循环在循环体之前检查循环条件，而<code>do-while</code>则是在循环提之后检查。</p>
<p><strong><em>while</em></strong> 循环：</p>
<pre class="mermaid">flowchart TD
    B{循环条件}--&gt;|true| C(循环体)
    C --&gt;|continue| B
    C --&gt;|break|E
    B ----&gt;|false| E([End])
</pre>
<p><strong><em>do-while</em></strong> 循环：</p>
<pre class="mermaid">flowchart TD
    C(循环体) --&gt;|continue| B{循环条件}
    B --&gt;|true| C
    C --&gt;|break|E
    B ----&gt;|false| E([End])

</pre>
<p>下面这段代码先打印数字0到9，再打印数字10到1（递减）。</p>
<pre><code class="language-dart">//ch0102_7.dart
void main() {
  // print 0,1,...,9
  var x = 0;
  while (x &lt; 10) {
    print(x++);
  }

  // print 10,9,...,1
  do {
    print(x--);
  } while (x &gt; 0);
}
</code></pre>
<h2 id="break-和-continue"><a class="header" href="#break-和-continue"><code>break</code> 和 <code>continue</code></a></h2>
<p><code>break</code>用于跳出当前循环，<code>continue</code>用于跳转至下一次迭代。下面这段代码使用<code>for</code>循环，打印1到9之间的奇数。</p>
<pre><code class="language-dart">// ch0202_8.dart
void main() {
  for (var x = 1; ; x++) {
    if (x == 10) break;
    if (x % 2 == 0) continue;
    print(x);
  }
}
</code></pre>
<h2 id="标签"><a class="header" href="#标签">标签</a></h2>
<p><code>break</code> 和 <code>continue</code> 仅对所在的（内层）循环起作用。如果要跳出（<code>break</code>）外层循环，或跳转至（<code>continue</code>）外层循环的下一次迭代，须借助标签。标签是一个标识符，后跟冒号（<code>labelName:</code>）；将标签放在语句之前以创建带标签的语句。</p>
<pre><code class="language-dart">// ch0202_9.dart

import 'dart:io';

void main() {
  outerLoop:
  for (var i = 0; i &lt; 10; i++, print('')) {
    for (var j = 0; j &lt; 10; j++) {
      if (j == 4) continue outerLoop;
      stdout.write(' ' * (i &gt; 0 ? 1 : 2));
      stdout.write(10 * i + j);
    }
  }
}
</code></pre>
<p>此例中的 <code>continue outerLoop;</code> 就相当于 <code>break</code>。</p>
<h2 id="小测验-1"><a class="header" href="#小测验-1">小测验</a></h2>
<ul>
<li>分别使用 <code>while</code> 和<code>do-while</code> 改写 <code>ch0202_8.dart</code>。</li>
<li>示例 <code>ch0202_9.dart</code> 中，如果将  <code>continue outerLoop;</code> 改为  <code>break outerLoop;</code> 程序的输出是什么？</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="断言"><a class="header" href="#断言">断言</a></h1>
<p>斷言（Assertion）是一个很有用的开发工具。下面的代码在调试模式（debug mode）下运行，将产生一个断言错误（AssertionError）。</p>
<pre><code class="language-dart">// ch0203_1.dart
void main() {
  var str = '';
  assert(str.isNotEmpty, "str cannot be empty");
  // do something else
}
</code></pre>
<p><code>assert</code> 接收2个参数，第一个参数必须是布尔表达式， 第二个参数是可选的，乃错误提示信息；在调试模式下，当第一个参数的值为<code>false</code>时，将出现断言错误。</p>
<p>断言仅在调试模式（debug mode）下起作用。对于发布模式（release mode），除非在编译时显示启用了断言， 所有的<code>assert</code> 语句都将被忽略，从而不会干预程序的执行流程。在Dart的相关命令中（例如 <code>dart run</code>、<code>dart compile exe</code>），通过<code>--enable-asserts</code> 参数启用断言，如</p>
<pre><code class="language-sh">dart run --enable-asserts bin/ch02/ch0203_1.dart
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函数-function"><a class="header" href="#函数-function">函数 （Function）</a></h1>
<p>本章节将介绍函数的基本概念，位置参数、命名参数、函数类型、匿名函数等内容，将在后续章节陆续介绍。我们已经多次见过<code>main</code>函数，它是程序的入口。抽象地说，函数对输入数据（输入参数列表）进行处理，然后输出其处理结果（返回值）。</p>
<pre class="mermaid">flowchart LR
   a(( )) --&gt;|输入参数| B(处理（函数体）)
   B --&gt; |返回值|c(( ))
</pre>
<p>先来看一个示例程序，计算平面上两点之间的欧式距离:</p>
<p>\( \sqrt{(x_1-x_2)^2 + (y_1-y_2)^2} \)</p>
<pre><code class="language-dart">//ch0204_1.dart
import 'dart:math';

typedef Point = ({double x, double y}); // 1

void main() {
  var a = (x: 1, y: 2), b = (x: 3, y: 4); // 2
  var distance = sqrt(
    (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y),
  ); // 3
  print('$a -&gt; $b: $distance'); // 3a

  var c = (x: 6, y: 5); //4
  distance = sqrt((a.x - c.x) * (a.x - c.x) + (a.y - c.y) * (a.y - c.y)); //5
  print('$a -&gt; $c: $distance'); // 5a
}

</code></pre>
<ol>
<li>使用<code>typedef</code>创建一个类型别名<code>Point</code>，它代表了二维平面里的一个点;</li>
<li>声明并初始化2个<code>Point</code>，<code>a</code> 和 <code>b</code>;</li>
<li>计算<code>a</code>、<code>b</code>间的欧式距离，随后打印 (3a)；</li>
<li>声明并初始化<code>Point c</code>;</li>
<li>计算<code>a</code>、<code>c</code>间的欧式距离，随后打印 (5a)；</li>
</ol>
<p>将计算欧式距离的代码，抽取成一个函数 <code>distance</code>，然后改写上例：</p>
<pre><code class="language-dart">//ch0204_2.dart
import 'dart:math';

typedef Point = ({double x, double y}); 

void main() {
  Point a = (x: 1, y: 2), b = (x: 3, y: 4);
  print('$a -&gt; $b: ${distance(a, b)}'); // 2

  Point c = (x: 6, y: 5);
  print('$a -&gt; $c: ${distance(a, c)}'); // 3
}

double distance(Point a, Point b) { // 1
  final dx = a.x - b.x;
  final dy = a.y - b.y;
  return sqrt(dx * dx + dy * dy);
}
</code></pre>
<ol>
<li>定义函数<code>distance</code>，它计算平面上两点间的欧式距离;</li>
<li>调用<code>distance</code>计算<code>a</code>、<code>b</code>间的欧式距离;</li>
<li>调用<code>distance</code>计算<code>a</code>、<code>c</code>间的欧式距离。</li>
</ol>
<p>重构（改写）后的程序，功能不变，但更为简洁易读，消除了重复代码（计算欧式距离），并可对该代码块（<code>distance</code> 函数）进行单元测试（第8章内容）。</p>
<h2 id="命名函数"><a class="header" href="#命名函数">命名函数</a></h2>
<p>通常，创建一个命名函数的语法为:</p>
<pre><code class="language-dart">返回值的类型 函数名称(输入参数列表){
   函数体
}
</code></pre>
<p>对于上述 <code>distance</code>函数：</p>
<ul>
<li>返回值的类型： <code>double</code>;</li>
<li>函数名称：<code>distance</code></li>
<li>输入参数列表：<code>Point a, Point b</code>
<ul>
<li><code>Point a</code> 表示输入参数 <code>a</code>的数据类型为<code>Point</code>;</li>
</ul>
</li>
<li>花括号（<code>{}</code>）内的代码为函数体;</li>
<li>使用<code>return</code>返回函数的返回值。</li>
</ul>
<p>如果函数没有返回值，用<code>void</code>表示：</p>
<pre><code class="language-dart">void printMe(String me) {
  print(me);
  // return;
}  
</code></pre>
<p>像此例中的<code>return;</code>，它位于函数体的最后一行，通常予以省略。</p>
<p>下面两点通常不被鼓励，除非你有充分的理由，因为它让Dart的静态类型分析失效：</p>
<ul>
<li>命名函数的返回值的类型，如果不写出来，就表示它是 <code>dynamic</code> （而不是<code>void</code>）;</li>
<li>类似地，命名函数的输入参数的类型，如果不写明，就代表<code>dynamic</code> 。</li>
</ul>
<h2 id="返回值"><a class="header" href="#返回值">返回值</a></h2>
<p>如果没有指定返回值，则语句 <code>return null;</code> 会被隐式附加到函数体中，函数将返回<code>null</code>。</p>
<p>如果一个函数需要返回多个值，通常返回一个记录（Record）类型。</p>
<pre><code class="language-dart">// ch0204_3.dart
(bool ok, String) foo() {
  // Do something
  return (true, 'done');
}
</code></pre>
<h2 id="arrow-语法"><a class="header" href="#arrow-语法">arrow 语法</a></h2>
<p>如果函数体只有一个表达式，可以使用arrow（箭头）语法来简化。例如</p>
<pre><code class="language-dart">int increase(int value) {
  return value + 1;
}
</code></pre>
<p>使用arrow语法简化为：</p>
<pre><code class="language-dart">int increase(int value) =&gt; value + 1;
</code></pre>
<h2 id="getter-与-setter"><a class="header" href="#getter-与-setter">getter 与 setter</a></h2>
<p>getter 与 settter 是一种特殊的函数，分别使用 <code>get</code> 与  <code>set</code> 关键字定义 。</p>
<pre><code class="language-dart">// ch0204_5.dart
var _foo = 1;

int get foo =&gt; _foo;

set foo(int value) {
  if (value &gt; 0) {
    _foo = value;
  }
}

void main() {
  print('foo=$foo'); // Output: foo=1
  foo = 2;
  foo = -1;
  print('foo=$foo'); // Output: foo=2
}

</code></pre>
<p>此例中的<code>foo</code>在使用者看来，就像一个变量，但<code>foo</code> setter 给私有变量 <code>_foo</code>提供了额外的保护，它只将正数赋值给<code>_foo</code>。</p>
<h2 id="main函数"><a class="header" href="#main函数"><code>main</code>函数</a></h2>
<p>程序的入口<code>main</code>函数，返回<code>void</code>，有一个可选的参数，其类型为<code>List&lt;String&gt;</code>，用于命令行程序中。</p>
<pre><code class="language-dart">// ch0204_4.dart
void main(List&lt;String&gt; args) {
  for (var arg in args) {
    print(arg);
  }
}
</code></pre>
<p>此程序打印命令行参数，一个参数一行。使用<code>dart run</code>运行它:</p>
<pre><code class="language-sh">$ dart run bin/ch02/ch0204_4.dart hello dart
hello
dart
</code></pre>
<blockquote>
<p><strong><em>NOTE:</em></strong> 可使用 <a href="https://pub.dev/packages/args">args 库</a>来定义和解析命令行参数。</p>
</blockquote>
<h2 id="外部函数external-function"><a class="header" href="#外部函数external-function">外部函数（external function）</a></h2>
<p>外部函数的函数体（实现）与函数声明是分离的。外部函数的实现可以来自另一个Dart库，更常见的是，来自其它编程语言（例如C）。使用 <code>external</code> 声明一个外部函数，例如 <code>Object</code>类中的 <code>toString()</code>  方法:</p>
<pre><code class="language-dart">  external String toString();
</code></pre>
<h2 id="小测验-2"><a class="header" href="#小测验-2">小测验</a></h2>
<p>下例中的<code>printMe2</code>的返回类型是什么？实际上它返回了什么？参数<code>me</code>的类型又是什么？</p>
<pre><code class="language-dart">printMe2(me) {
  print(me);
}
</code></pre>
<h2 id="参考资料-7"><a class="header" href="#参考资料-7">参考资料</a></h2>
<ul>
<li><a href="https://dart.dev/language/functions">https://dart.dev/language/functions</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函数参数"><a class="header" href="#函数参数">函数参数</a></h1>
<p>函数参数有<a href="ch02/dartpl0205.html#%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0">位置参数</a>和<a href="ch02/dartpl0205.html#%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0">命名参数</a>之分，另外还有<a href="ch02/dartpl0205.html#%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0">可选参数</a>。</p>
<h2 id="位置参数"><a class="header" href="#位置参数">位置参数</a></h2>
<p>上一节中的示例函数，只使用了位置参数，这些参数在参数列表中的顺序至关重要。</p>
<pre><code class="language-dart">// ch0205_1.dart
void main(List&lt;String&gt; args) {
  print(power(2, 5)); // 2 Output: 32
  print(power(5, 2)); // 3 Output: 25
}

int power(int base, int exponent) { // 1
  int result = 1;
  for (int i = 0; i &lt; exponent; i++) {
    result *= base;
  }
  return result;
}
</code></pre>
<ol>
<li>创建函数<code>power</code>， 返回 <code>base</code>的<code>exponent</code>次方;</li>
<li>打印 2 的 5 次方（32）;</li>
<li>打印 5 的 2 次方（25）。</li>
</ol>
<p>可见在调用<code>power</code>函数时，必须注意参数的顺序。</p>
<h2 id="命名参数"><a class="header" href="#命名参数">命名参数</a></h2>
<p>命名参数，顾名思义，就是有名字的参数。下面使用命名参数来创建<code>power</code>函数：</p>
<pre><code class="language-dart">// ch0205_2.dart
void main() {
  print(power(base: 2, exponent: 5)); // 2 Output: 32
  print(power(exponent: 2, base: 5)); // 3 Output: 25
}

power({required int base, required int exponent}) { // 1
  // ... (omited for brevity)
}
</code></pre>
<p>语法方面，</p>
<ul>
<li>命名参数被一对花括号（<code>{}</code>）包围；</li>
<li><code>required</code> 关键字，表示函数的调用方必须传递该参数；</li>
<li>调用函数时，采用<code>参数名:参数值</code>的形式（如<code>base: 2</code>），给命名参数传值 。</li>
</ul>
<h2 id="可选参数"><a class="header" href="#可选参数">可选参数</a></h2>
<p>对于命名参数，无<code>required</code>修饰时，表示是可选的。</p>
<p>无论是位置参数还是命名参数：</p>
<ul>
<li>对<code>nullable</code>（可空）参数，可选参数的默认值是<code>null</code>;</li>
<li>对<code>non-nullable</code> （不可空）参数，必须指定一个默认值，才能成为可选参数;</li>
<li>在参数名后使用 <code>=</code> 来指定默认值。</li>
</ul>
<pre><code class="language-dart">// ch0205_3.dart
void main() {
  print(increase(5)); // Output: 6
  print(increase(5, increment: 2)); // Output: 7

  print(descrease(5)); // Output: 4
  print(descrease(5, 2)); // Output: 3
}

int increase(int value, {int increment = 1}) =&gt; value + increment;

int descrease(int value, [int? decrement]) =&gt; value - (decrement ?? 1);
</code></pre>
<p>可选的位置参数（可以是多个），必须放在参数列表的最后，放在一对中括号里（<code>[ ]</code>）。</p>
<h2 id="混合使用位置参数与命名参数"><a class="header" href="#混合使用位置参数与命名参数">混合使用位置参数与命名参数</a></h2>
<p>位置参数和命名参数可以混合使用，如上例中的<code>int increase(int value, {int increment = 1})</code>，但混合使用时：</p>
<ul>
<li>位置参数必须在参数列表的开头（即先定义位置参数）;</li>
<li>此时不能定义可选的位置参数。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函数类型匿名函数与闭包"><a class="header" href="#函数类型匿名函数与闭包">函数类型、匿名函数与闭包</a></h1>
<p>在Dart里，函数像普通变量一样，可作为参数传递，或从一个函数返回，这便是所谓的函数乃一等公民（first-class object）。在Dart里可以定义<a href="ch02/dartpl0206.html##%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0">匿名函数</a> ，也就是没有名称的函数，这在实际应用中极为方便。<a href="ch02/dartpl0206.html#%E9%97%AD%E5%8C%85closure">闭包（Closure）</a>是与之相关的另一个重要的概念，详见后文。</p>
<h2 id="函数类型"><a class="header" href="#函数类型">函数类型</a></h2>
<p>首先通过一个示例，来看一看什么是函数类型（funtion type）。</p>
<pre><code class="language-dart">// ch0206_1.dart
void main() {
  int increase(int value, {int increment = 1}) =&gt; value + increment; // 3
  var increaseFunc = increase; // 4

  print(addFunc); // 5
  print(increaseFunc); // 5a

  //Output:
  //Closure: (int, int) =&gt; int from Function 'add': static.
  //Closure: (int, {int increment}) =&gt; int
}

int add(int a, int b) =&gt; a + b; // 1

int Function(int a, int b) addFunc = add; // 2

int Function(int, int) addFunc2 = add; // 2a

var addFunc3 = add; // 2b
</code></pre>
<ol>
<li>声明函数<code>add</code>;</li>
<li>声明变量<code>addFunc</code> 并赋值为<code>add</code>，它的类型是一个函数类型 <code>int Function(int a, int b) </code>， 可见函数类型的写法与声明一个函数类似，去掉函数体，然后将函数名称换成关键字<code>Function</code>即可，同时可省略位置参数的名称（2a）;</li>
<li>在<code>main</code>函数的内部，声明函数<code>increase</code>;</li>
<li>声明变量<code>increaseFunc</code> 并赋值为<code>increase</code>;</li>
<li>打印<code>addFunc</code>与<code>increaseFunc</code>，注意观察其输出。</li>
</ol>
<p><code>increase</code> 函数定义在<code>main</code>函数的内部，这便是嵌套函数的概念。<code>Closure: (int, int) =&gt; int from Function 'add': static.</code>，这表明<code>addFunc</code>的值是一个<a href="ch02/dartpl0206.html#%E9%97%AD%E5%8C%85closure">闭包（Closure）</a>，并且它来自全局（<code>static</code>）的<code>add</code>函数。这里的全局讲的是作用域（Lexical Scope）。</p>
<h2 id="使用-typedef"><a class="header" href="#使用-typedef">使用 <code>typedef</code></a></h2>
<p>使用 <code>typedef</code> 关键字给函数类型取一个别名：</p>
<pre><code class="language-dart">typedef AddFunction = int Function(int a, int b);
AddFunction addFunc4 = add;

typedef VoidCallback = void Function();
</code></pre>
<p><code>typedef</code> 也用于给数据类型取别名：</p>
<pre><code class="language-dart">typedef IntList = List&lt;int&gt;;
</code></pre>
<h2 id="词法范围lexical-scope"><a class="header" href="#词法范围lexical-scope">词法范围（Lexical Scope）</a></h2>
<p>从语法上看，一对花括号（<code>{}</code>）便定义了一个词法范围，即作用域。作用域嵌套而成，外层作用域内的变量对内层可见，反之不然。下面是来自<a href="https://dart.dev/language/functions#lexical-scope">官方文档</a>的示例:</p>
<pre><code class="language-dart">// ch0206_2.dart
bool topLevel = true;

void main() {
  var insideMain = true;

  void myFunction() {
    var insideFunction = true;

    void nestedFunction() {
      var insideNestedFunction = true;

      assert(topLevel);
      assert(insideMain);
      assert(insideFunction);
      assert(insideNestedFunction);
    }
  }
}
</code></pre>
<h2 id="匿名函数"><a class="header" href="#匿名函数">匿名函数</a></h2>
<p>像<code>main </code>、<code>print</code>这些是命名（具名）函数。我们也可以创建没有名称的函数，称之为匿名函数，或lambda表达式 或 闭包。</p>
<p>匿名函数经常作为其他函数的参数，它与命名函数类似，特别之处在于：</p>
<ul>
<li>没有函数名称；</li>
<li>也无需声明返回值的类型；</li>
<li>参数的类型是可选的。</li>
</ul>
<p>语法格式：</p>
<pre><code class="language-dart">(参数列表) {
  函数体
}
</code></pre>
<p>下面的示例程序分析一句英文，然后打印其中的单词及其长度。</p>
<pre><code class="language-dart">// ch0206_3.dart
void main() {
  var sentence = 'Its quaint events were hammered out'; // 1
  var stats = sentence.split(' ').map((word) =&gt; (word, word.length)); // 2
  stats.forEach(print); // 3
  // Output:
  // (Its, 3)
  // (quaint, 6)
  // (events, 6)
  // (were, 4)
  // (hammered, 8)
  // (out, 3)
}
</code></pre>
<ol>
<li><code>sentence</code>是一句英文;</li>
<li><code> sentence.split(' ')</code> 使用空格符（<code>' '</code>）分割 <code>sentence</code>，得到一个单词（<code>word</code>）的列表;
然后将每个单词映射（<code>map</code>）为一个记录，内容为单词及其长度（<code>(word, word.length)</code>）;
这一句结束时将得到统计结果<code>stats</code>，它是一个 <a href="https://api.dart.dev/dart-core/Iterable-class.html"><code> Iterable</code> 对象</a>（可将<code>Iterable</code>简单理解为一个更为泛化的列表，通过特定的方法访问其元素）;</li>
<li>使用<code>Iterable.forEach</code> 方法，打印<code>stats</code> 中的每个元素，这里将<code>print</code>函数作为参数传入<code>forEach</code>。</li>
</ol>
<p>第2句中的<code>(word) =&gt; (word, word.length)</code> 是一个匿名函数，它作为参数传入<code>map</code>函数。</p>
<h2 id="闭包closure"><a class="header" href="#闭包closure">闭包（Closure）</a></h2>
<p>闭包是一个容易让人迷糊的概念。简言之，闭包是一个函数（或函数值、函数对象），很多时候它是一个匿名函数。闭包这个概念之所以会诞生，是因为它的实用性与特殊性：</p>
<blockquote>
<p>闭包即使脱离了定义它的作用域（原始作用域），依然可以访问原始作用域内的变量。</p>
</blockquote>
<p>如果一门编程语言具有上述特性，比如Dart，我们就说Dart支持闭包，可见闭包这个词也用来表示编程语言的这一特点(feature)。</p>
<p>下面这个示例来自<a href="https://dart.dev/language/functions#lexical-closures">官方文档</a>：</p>
<pre><code class="language-dart">// ch0206_4.dart
Function makeAdder(int addBy) {// 1
  return (int i) =&gt; addBy + i; // funcA
}

void main() {
  var add2 = makeAdder(2); // 2
  var add4 = makeAdder(4); // 2a

  assert(add2(3) == 5); // 3
  assert(add4(3) == 7); // 3a
}
</code></pre>
<ol>
<li><code>makeAdder</code>是一个函数，它返回一个匿名函数 <code> (int i) =&gt; addBy + i;</code> ，为方便描述，称之为<code>funcA</code>;</li>
<li>分别调用 <code>makeAdder(2)</code>、 <code>makeAdder(4)</code>  得到函数 <code>add2</code>、<code>add4</code>;</li>
<li>断言 <code>add2(3)</code>等于5， 断言 <code>add4(3)</code>等于7。</li>
</ol>
<p><code>add2</code>、<code>add4</code> 都记住了<code>makeAdder</code>被调用时的<code>addBy</code>（<code>makeAdder</code>的参数）。从数学的角度来看<code>funcA</code>:</p>
<p>\( funcA( i ) = addBy + i \)</p>
<p>这个函数里的自变量是<code>i</code>， <code>addBy</code>是一个常量。 <code>add2 = makeAdder(2)</code>， 相当于指定常量 <code>addBy = 2</code>，<code>add4</code>类似。<code>add2</code>、<code>add4</code> 等都是闭包。</p>
<h2 id="小测验-3"><a class="header" href="#小测验-3">小测验</a></h2>
<p>修改示例程序<code>ch0206_3.dart</code>，将统计结果按单词的长度降序排序。提示：使用<code>List.sort</code>方法。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="递归"><a class="header" href="#递归">递归</a></h1>
<p>如果一个函数直接或间接调用它自己，我们便称之为递归函数。之所以讨论它，是因为递归是一种解决问题的有效方法，也是一种分治的思想，它针对特定的问题，这类问题在结构上可以进一步分解为相似的子问题。例如阶乘函数：</p>
<p>\( n! = (n-1)!*n \)</p>
<p>下面的代码计算斐波那契（Fibonacci）数列：</p>
<p>\( fib(0)=0, fib(1) = 1 \)</p>
<p>\( fib(n) = fib(n-1) + fib(n-2),   n &gt;1 \)</p>
<pre><code class="language-dart">// ch0207_1.dart
void main() {
  var n = 20;
  print('fib($n) = ${fib(n).$2}'); // Output: fib(20) = 6765
}

/// fib function returns (fib(n - 1), fib(n))
(int, int) fib(int n) {
  if (n &lt;= 1) return (0, 1);
  var (a, b) = fib(n - 1);
  return (b, a + b);
}
</code></pre>
<p>又如使用辗转相除法，计算两个整数的最大公约数（最大公因数）：</p>
<p>\( gcd(a, b) = gcd(b, a\%b) \)</p>
<pre><code class="language-dart">// ch0207_1.dart
void main() {
  var a = 234, b = 678;
  print('gcd($a, $b) = ${gcd(a, b)}'); // Output: gcd(234, 678) = 6
}

/// Greatest common divisor
int gcd(int a, int b) {
  if (b == 0) return a;
  return gcd(b, a % b);
}
</code></pre>
<blockquote>
<p><strong><em>NOTE:</em></strong> 辗转相除法</p>
<ol>
<li>用较大数除以较小数，得到余数;</li>
<li>如果余数为0，则除数即为最大公约数（算法终止），否则转下一步;﻿</li>
<li>用余数代替原来的除数，用原来的除数代替原来的被除数，转第1步。﻿</li>
</ol>
</blockquote>
<h2 id="递归与循环"><a class="header" href="#递归与循环">递归与循环</a></h2>
<p>有时，递归函数可以用循环来改写，例如：</p>
<pre><code class="language-dart">/// Greatest common divisor (loop version)
int gcd2(int a, int b) {
  while (b != 0) {
    (a, b) = (b, a % b);
  }
  return a;
}
</code></pre>
<p><code>gcd2</code>与<code>gcd</code>函数的功能一样，只不过使用了循环而非递归来实现。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="异常处理"><a class="header" href="#异常处理">异常处理</a></h1>
<p>Dart代码可以抛出（<code>throw</code>）和捕获（<code>catch</code>）异常（<code>Exception</code>）。异常代表了程序的某种错误，也就是一些意想不到的事情。引发异常的代码分支及其上下文，即测试中的负向路径。</p>
<p>Dart的函数或方法不会声明它将抛出哪些异常; Dart也不强制要求捕获异常。如果异常发生了却不被处理，抛出异常的 isolate 将被挂起，且通常会被终止。第7章将详细讨论 isolate，这里将其视为一种内存独立的线程（如 <code>main</code> 函数所在的 main isolate）即可。</p>
<h2 id="抛出异常-trhow"><a class="header" href="#抛出异常-trhow">抛出异常 （<code>trhow</code>）</a></h2>
<p>Dart程序可以抛出（<code>trhow</code>）什么？答案是除了<code>null</code>外的任何东西。</p>
<pre><code class="language-dart">// ch0208_1.dart
void main() {
  throw 'something bad happened';
  // Unhandled exception:
  // something bad happened
}
</code></pre>
<p>此例使用<code>throw</code> 关键字，抛出了一个字符串。</p>
<h3 id="exception-和-error"><a class="header" href="#exception-和-error"><code>Exception</code> 和 <code>Error</code></a></h3>
<p>Dart提供了 <code>Exception</code> 和 <code>Error</code> 类及相关子类（第4章将介绍类），官方建议我们在产品代码中抛出 <code>Exception</code> 或 <code>Error</code> 的实现类。例如下面这些类实现了<code>Exception</code>：</p>
<ul>
<li><code>AnalysisException</code></li>
<li><code>DeferredLoadException</code></li>
<li><code>FileSystemException</code></li>
<li><code>FormatException</code></li>
<li><code>IOException</code></li>
<li><code>IsolateSpawnException</code></li>
<li><code>PathException</code></li>
<li><code>RemoteException</code></li>
<li><code>TimeoutException</code></li>
</ul>
<p>我们也可以创建自己的异常类，并实现（<code>implements</code>） <code>Exception</code> 或 <code>Error</code>。</p>
<pre><code class="language-dart">// ch0208_2.dart
void main() {
  throw FooException();
}

class FooException implements Exception {}
</code></pre>
<p><code>Exception</code> 与 <code>Error</code> 的区别：</p>
<ul>
<li>
<p><code> Exception</code>旨在向外传递一个失败信息（例如超时异常 <code>TimeoutException</code>），以便通过编程的方式解决；它应该包含有用的信息，且希望被捕获。</p>
</li>
<li>
<p><code>Error</code>代表了程序员引起的错误（例如断言错误 <code>AssertionError</code>）， 它理应被避免，且通常暗示了一个bug，我们不应捕获它。</p>
</li>
</ul>
<h2 id="捕获异常"><a class="header" href="#捕获异常">捕获异常</a></h2>
<h3 id="捕获指定类型的异常"><a class="header" href="#捕获指定类型的异常">捕获指定类型的异常</a></h3>
<p>使用 <code>try...on...catch</code> 语法捕获异常。将可能抛出异常的代码放在<code>try{}</code>代码块中，然后使用<code>on</code>关键字捕获特定类型的异常。</p>
<pre><code class="language-dart">// ch0208_3.dart
import 'dart:io';

void main() {
  var str = 'dart';
  try {
    int.parse(str);
  } on FormatException {
    stderr.writeln('FormatException: Cannot parse "$str" as an integer.');
  }
}
</code></pre>
<p>此例试图将字符串<code>"dart"</code>转换为一个整数，引发了 <code>FormatException</code>，随后被捕获。</p>
<h3 id="捕获异常信息"><a class="header" href="#捕获异常信息">捕获异常信息</a></h3>
<p>使用<code>catch</code>关键字捕获异常信息（即异常类型的一个实例）。</p>
<pre><code class="language-dart">// ch0208_4.dart
void main() {
  try {
    int.parse('dart');
  } on FormatException catch (ex) {
    print(ex.message); // Output: Invalid radix-10 number
  } 
}
</code></pre>
<p><code>catch()</code> 还有另一个可选参数，表示异常堆栈。</p>
<pre><code class="language-dart">// ch0208_5.dart
void main() {
  try {
    int.parse('dart');
  } on FormatException catch (e, s) {
    print(e);
    print(s);
  }
}
</code></pre>
<h3 id="重新抛出异常"><a class="header" href="#重新抛出异常">重新抛出异常</a></h3>
<p>使用 <code>rethrow</code>关键字重新抛出异常，且保留原来的堆栈信息。</p>
<pre><code class="language-dart">// ch0208_6.dart
void main() {
  try {
    parseInt('dart');
  } catch (_, s) {// 2
    print(s); // 2a
  }
}

int parseInt(String str) {
  try {
    return int.parse(str);
  } on FormatException catch (_, s) {
    print(s); // 1a
    rethrow; // 1
  }
}
</code></pre>
<ol>
<li>使用<code>rethow</code>关键字将捕获到的<code>FormatException</code>再次抛出;</li>
<li>这里仅用了<code>catch</code> （没有使用<code>on</code>指定异常类型），表示捕获所有类型的异常。</li>
</ol>
<h3 id="捕获多种类型的异常"><a class="header" href="#捕获多种类型的异常">捕获多种类型的异常</a></h3>
<p>使用多个<code>catch</code>子句来分别处理不同类型的异常。</p>
<pre><code class="language-dart">//ch0206_7.dart
void main() {
  print(safeDivide('8', '2'));
  print(safeDivide('8', '0'));
  print(safeDivide('hello', 'dart'));
}

(String? err, int) safeDivide(String a, String b) {
  try {
    return (null, int.parse(a) ~/ int.parse(b));
  } on FormatException catch (e) {
    return ('FormatException: ${e.source}', 0);
  } on UnsupportedError catch (e) { // IntegerDivisionByZeroException
    return ('UnsupportedError: ${e.message}', 0);
  } on Exception catch (e) {
    return ('unknown exception: $e', 0);
  }
}
</code></pre>
<h2 id="finally"><a class="header" href="#finally"><code>finally</code></a></h2>
<p>无论<code>try</code> 代码块内是否发生了异常， <code>finally</code>子句都将被执行。<code>finally</code>子句通常用来关闭资源（如打开的系统文件）。</p>
<pre><code class="language-dart">// ch0208_8.dart
void main() {
  try {
    print(2 ~/ 0);
  } on UnsupportedError {
    print('oops');
  } finally {
    print('done');
  }
  // Output:
  // oops
  // done
}
</code></pre>
<h2 id="参考资料-8"><a class="header" href="#参考资料-8">参考资料</a></h2>
<ul>
<li><a href="https://dart.dev/language/error-handling">https://dart.dev/language/error-handling</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模式"><a class="header" href="#模式">模式</a></h1>
<p>Dart 3.0引入了一个非常强大的功能，模式（Pattern）。一般来说，依据模式的形状及其上下文， 模式可以<a href="ch03/dartpl0301.html#%E5%8C%B9%E9%85%8D">匹配（match）</a>或<a href="ch03/dartpl0301.html#%E8%A7%A3%E6%9E%84">解构（destructure)</a>一个值，匹配与解构可同时进行。</p>
<h2 id="匹配"><a class="header" href="#匹配">匹配</a></h2>
<p>模式匹配可以检查一个值是否：</p>
<ul>
<li>具有特定的形状;</li>
<li>是特定常数;</li>
<li>等于某个值;</li>
<li>有特定的数据类型。</li>
</ul>
<p>这么说还是有点抽象，我们来看下面的示例。</p>
<pre><code class="language-dart">//ch0301_1.dart
void main() {
  const numbers = [1, 2, 3]; // 1

  if (numbers case [_, _, _]) { // 2
    print('numbers is a list which has 3 elements.');
  }

  if (numbers case [1, 2, 3]) { // 3
    print('numbers is exactly [1, 2, 3].');
  }

  const point = (x: 3, y: 4); // 4
  
  if (point case (x: _, y: _)) { // 5
    print("point is a record with named fields x and y.");
  }
}

</code></pre>
<ol>
<li>声明了一个<code>const</code>列表<code>numbers</code>;</li>
<li>检查<code>numbers</code>是否是一个具有2个元素的列表;</li>
<li>检查<code>numbers</code>是否就等于<code> [1, 2, 3]</code>;</li>
<li>声明一个记录<code>point</code>;</li>
<li>检查<code>point</code>是否是一个具有命名字段 <code>x</code> 和 <code>y</code> 的记录（record）。</li>
</ol>
<h2 id="解构"><a class="header" href="#解构">解构</a></h2>
<p>模式解构提供了一种便捷的声明式语法，可以将一个值分解成各部件（parts），并将部分或全部的部件，绑定至局部变量。</p>
<pre><code class="language-dart">//ch0301_2.dart
void main() {
  const numbers = [1, 2, 3]; 

  if (numbers case [var a, var b, _]) { // 1
    print('a=$a b=$b'); 
  }

  if (numbers case [var a, ...var rest]) { // 2
    print('The first element is $a, and the rest is $rest'); 
  }

  const point = (x: 3, y: 4); 

  if (point case (x: var a, :var y)) { // 3
    print("a=$a y=$y");
  }
}
</code></pre>
<ol>
<li>匹配<code>numbers</code>并绑定前2个元素至变量<code>a</code>和<code>b</code>;</li>
<li>匹配<code>numbers</code>并绑定第1元素至变量<code>a</code>，绑定剩余的元素至变量<code>rest</code>，注意<code>var rest</code>之前有3个点（<code>....</code>）;</li>
<li>匹配<code>point</code>，并将其<code>x</code>字段绑定至变量<code>a</code>，<code>y</code>字段绑定至变量<code>y</code>；这里的<code>:var y</code>乃<code>y:var y</code>的简便写法。</li>
</ol>
<p>下面是与类相关的模式匹配的一个示例：</p>
<pre><code class="language-dart">// ch0301_3.dart
void main() {
  const point = Point(3, 4); // 4
  if (point case Point(:var x, :var y, :var z)) { // 5
    print("x=$x, y=$y, z=$z"); 
  }
}

class Point { 
  const Point(this.x, this.y); // 1

  final int x; // 2
  final int y; // 2a
  int get z =&gt; x + y; // 3
}
</code></pre>
<ol>
<li>这是类<code>Point</code>的构造函数；</li>
<li><code>x</code> 与<code> y</code> 是<code>Point</code> 的两个公开的字段;</li>
<li><code>z</code> 是 getter 方法，由<code>x</code>和<code>y</code>计算而成，形式上当成字段来用；</li>
<li>声明一个变量<code>point</code>，它<code>Point</code>类的一个实例；</li>
<li>解构<code>point</code>，并将其部件分别绑定值变量 <code>x</code>、<code>y</code>、<code>z</code>。</li>
</ol>
<p>解构不但可以绑定字段，还可以绑定函数/方法（在类中定义的函数），也就是为什么在描述解构时，采用了部件（而非字段）这个词。</p>
<pre><code class="language-dart">// ch0301_4.dart
void main() {
  const rect = Rectangle(5, 6);
  if (rect case Rectangle(:var area)) {
    print("${area(.1)} m²");
  }
}

class Rectangle {
  const Rectangle(this.a, this.b);

  final double a;
  final double b;

  double area([double unit = 1]) =&gt; a * b * unit * unit;
}
</code></pre>
<h2 id="参考资料-9"><a class="header" href="#参考资料-9">参考资料</a></h2>
<ul>
<li><a href="https://dart.dev/language/patterns">https://dart.dev/language/patterns</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模式的使用场景"><a class="header" href="#模式的使用场景">模式的使用场景</a></h1>
<p>模式可用于下列地方：</p>
<ul>
<li><a href="ch03/dartpl0302.html#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E5%92%8C%E8%B5%8B%E5%80%BC">局部变量声明和赋值</a></li>
<li><a href="ch03/dartpl0302.html#if-case-%E5%92%8C-switch-case">if-case 和 switch-case</a></li>
<li><a href="ch03/dartpl0302.html#for-%E5%92%8C-for-in-%E5%BE%AA%E7%8E%AF">for 和 for-in 循环</a></li>
<li><a href="ch03/dartpl0302.html#%E9%9B%86%E5%90%88%E5%AD%97%E9%9D%A2%E9%87%8Fcollection-literals%E4%B8%AD%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81">集合字面量（collection literals）中的控制流(if、for)</a></li>
</ul>
<h2 id="局部变量声明和赋值"><a class="header" href="#局部变量声明和赋值">局部变量声明和赋值</a></h2>
<pre><code class="language-dart">// ch0302_1.dart
void main() {
  var (name, :id, [a, b, c]) = ('Tom', id: 1, [3, 4, 5]); // 1
  print('name=$name id=$id a=$a b=$b c=$c');
  // Output: name=Tom id=1 a=3 b=4 c=5

  (a, b) = (b, a); // 2
  print('a=$a b=$b'); // Output: a=4 b=3
}
</code></pre>
<ol>
<li>这行代码展示了模式如何用于局部变量声明;</li>
<li>这里使用了模式的局部变量赋值，交换两个变量的值。</li>
</ol>
<h2 id="if-case-和-switch-case"><a class="header" href="#if-case-和-switch-case">if-case 和 switch-case</a></h2>
<p>每个case子句都包含了一个模式，无论是if-case 还是switch-case。</p>
<pre><code class="language-dart">// ch0302_2.dart
void main() {
  const data = ('Tom', id: 1, [3, 4, 5]);
  if (data case ('Tom' || 'Jerry', id: _, _)) { // 1
    print('Hey, my friend!');
  }

  switch (data) {
    case ('Tom', :var id, _):
      print('Hi, Tom! Your ID is $id.');
    case ('Jerry', :var id, _):
      print('Hi, Jerry! Your ID is $id.');
    default:
      print('Hi! Who are you?');
  }
}
</code></pre>
<ol>
<li>这里使用了逻辑或（OR）操作符（<code>||</code>），让<code>data.$1</code>匹配多个值，这非常实用。</li>
</ol>
<h2 id="for-和-for-in-循环"><a class="header" href="#for-和-for-in-循环">for 和 for-in 循环</a></h2>
<pre><code class="language-dart">// ch0302_3.dart
void main() {
  var points = [Point(0, 1), Point(1, 2), Point(2, 3)]; // 2
  for (var Point(:x, :y) in points) { // 3
    print('x=$x y=$y');
  }
}

class Point { // 1
  const Point(this.x, this.y);
  final double x;
  final double y;
}
</code></pre>
<ol>
<li>定义<code>Point</code>类，它包括<code>x</code>和<code>y</code>两个字段;</li>
<li><code>points</code>是一个<code>Point</code>列表;</li>
<li>在for-in语句中解构points中的每个<code>Point</code>，将其部件绑定至局部变量<code>x</code>和<code>y</code>。</li>
</ol>
<h2 id="集合字面量collection-literals中的控制流"><a class="header" href="#集合字面量collection-literals中的控制流">集合字面量（collection literals）中的控制流</a></h2>
<p>集合包括List、Set、Map，将在第6章将详细讨论，这里仅以List（列表）为例，对模式的相关使用进行说明。</p>
<p>首先来看如何使用for语句创建一个列表，以及<code>for</code>与<code>if</code>的嵌套使用。下面的程序将打印数字0到9中的偶数。</p>
<pre><code class="language-dart">// ch0302_4.dart
void main() {
  final nums = [for (var i = 0; i &lt; 10; i++) i]; // 1
  var evenNums = [
    for (var num in nums) // 2
      if (num.isEven) num,
  ];
  print(evenNums); // Output: [0, 2, 4, 6, 8]
}
</code></pre>
<ol>
<li>在集合字面量中使for语句，创建一个0到9的数字列表<code>nums</code>;</li>
<li>对<code>nums</code>进行过滤（<code>if(num.isEven)</code>），选出其中的偶数。</li>
</ol>
<p>下例演示了如何在集合字面量的控制流中使用模式。</p>
<pre><code class="language-dart">// ch0302_5.dart
void main() {
  var points = [for (var x = 0; x &lt; 10; x++) (x: x, y: 2 * x)];
  var points2 = [
    for (var (:x, :y) in points)
      if (x.isEven) (x: x, y: y),
  ];
  print(points2);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模式类型"><a class="header" href="#模式类型">模式类型</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模式应用案例"><a class="header" href="#模式应用案例">模式应用案例</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="封装与可见性"><a class="header" href="#封装与可见性">封装与可见性</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="构造函数this关键字与初始化列表"><a class="header" href="#构造函数this关键字与初始化列表">构造函数、this关键字与初始化列表</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="命名构造器"><a class="header" href="#命名构造器">命名构造器</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="重定向构造器"><a class="header" href="#重定向构造器">重定向构造器</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="factory构造器"><a class="header" href="#factory构造器">factory构造器</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用late延迟初始化"><a class="header" href="#使用late延迟初始化">使用late延迟初始化</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="const构造器与const变量"><a class="header" href="#const构造器与const变量">const构造器与const变量</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getter-与-setter-方法"><a class="header" href="#getter-与-setter-方法">getter 与 setter 方法</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="操作符重载"><a class="header" href="#操作符重载">操作符重载</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="callable-类"><a class="header" href="#callable-类">callable 类</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="枚举"><a class="header" href="#枚举">枚举</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="注解"><a class="header" href="#注解">注解</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="super构造器"><a class="header" href="#super构造器">super构造器</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="抽象类"><a class="header" href="#抽象类">抽象类</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="接口与implements关键字"><a class="header" href="#接口与implements关键字">接口与implements关键字</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用mixin创建可复用代码"><a class="header" href="#使用mixin创建可复用代码">使用Mixin创建可复用代码</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用extension扩展已有的类"><a class="header" href="#使用extension扩展已有的类">使用extension扩展已有的类</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="范型"><a class="header" href="#范型">范型</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="列表-list"><a class="header" href="#列表-list">列表 List</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="集合-set"><a class="header" href="#集合-set">集合 Set</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用-map-创建键值对集合"><a class="header" href="#使用-map-创建键值对集合">使用 Map 创建"键值对"集合</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashcode-与equals-操作符"><a class="header" href="#hashcode-与equals-操作符">hashCode 与equals (==操作符)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transform方法"><a class="header" href="#transform方法">Transform方法</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="futureasync-与-await"><a class="header" href="#futureasync-与-await">Future、async 与 await</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterable-stream-sync-async-与-yield"><a class="header" href="#iterable-stream-sync-async-与-yield">Iterable 、Stream 、sync*、 async* 与 yield</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stream命名构造器"><a class="header" href="#stream命名构造器">Stream命名构造器</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用listenawait-for-订阅-stream"><a class="header" href="#使用listenawait-for-订阅-stream">使用listen()/await for 订阅 Stream</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="isolate介绍"><a class="header" href="#isolate介绍">Isolate介绍</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testgroup"><a class="header" href="#testgroup">test/group</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="测试异步代码"><a class="header" href="#测试异步代码">测试异步代码</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用mockito模拟外部依赖"><a class="header" href="#使用mockito模拟外部依赖">使用mockito模拟外部依赖</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dart命令行工具"><a class="header" href="#dart命令行工具">dart命令行工具</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solid编码准则"><a class="header" href="#solid编码准则">SOLID编码准则</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="编写dart命令行程序"><a class="header" href="#编写dart命令行程序">编写Dart命令行程序</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="编写dart服务端编程"><a class="header" href="#编写dart服务端编程">编写Dart服务端编程</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dart-常用package介绍"><a class="header" href="#dart-常用package介绍">Dart 常用package介绍</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/mermaid.min.js"></script>
        <script src="theme/mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
